<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Memory Management in C++" /><meta name="author" content="<author_id>" /><meta property="og:locale" content="en" /><meta name="description" content="A Complete Guide to Memory Management in C++" /><meta property="og:description" content="A Complete Guide to Memory Management in C++" /><link rel="canonical" href="https://bhaswanth-a.github.io//posts/memory-management-cpp/" /><meta property="og:url" content="https://bhaswanth-a.github.io//posts/memory-management-cpp/" /><meta property="og:site_name" content="Bhaswanth Ayapilla" /><meta property="og:image" content="https://bhaswanth-a.github.io//assets/images/ldr.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2026-01-01T11:00:00-05:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://bhaswanth-a.github.io//assets/images/ldr.png" /><meta property="twitter:title" content="Memory Management in C++" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@<author_id>" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"<author_id>"},"dateModified":"2026-01-01T11:00:00-05:00","datePublished":"2026-01-01T11:00:00-05:00","description":"A Complete Guide to Memory Management in C++","headline":"Memory Management in C++","image":"https://bhaswanth-a.github.io//assets/images/ldr.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://bhaswanth-a.github.io//posts/memory-management-cpp/"},"url":"https://bhaswanth-a.github.io//posts/memory-management-cpp/"}</script><title>Memory Management in C++ | Bhaswanth Ayapilla</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Bhaswanth Ayapilla"><meta name="application-name" content="Bhaswanth Ayapilla"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/prfl.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Bhaswanth Ayapilla</a></div><div class="site-subtitle font-italic">Perception | Reinforcement Learning</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-user ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT ME</span> </a><li class="nav-item"> <a href="/projects/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>PROJECTS</span> </a><li class="nav-item"> <a href="/cmu/" class="nav-link"> <i class="fa-fw fas fa-school ml-xl-3 mr-xl-3 unloaded"></i> <span>CMU MRSD</span> </a><li class="nav-item"> <a href="/blog/" class="nav-link"> <i class="fa-fw fas fa-blog ml-xl-3 mr-xl-3 unloaded"></i> <span>BLOG</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/cv/" class="nav-link"> <i class="fa-fw fas fa-file ml-xl-3 mr-xl-3 unloaded"></i> <span>CURRICULUM VITAE</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-address-book ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Bhaswanth-A" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['bhaswanthayapilla','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="https://www.instagram.com/bhaswanth_a/" aria-label="instagram" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-instagram"></i> </a> <a href="https://www.linkedin.com/in/bhaswanth-a/" aria-label="linkedin" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-linkedin-in"></i> </a> <a href="https://bhaswanth-a.github.io/cv/" aria-label="cv" class="order-7" target="_blank" rel="noopener"> <i class="fas fa-file"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script> </span></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Memory Management in C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Memory Management in C++</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1767283200" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jan 1, 2026 </em> </span><div class="d-flex justify-content-between"> <span> By <em> Bhaswanth Ayapilla </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3676 words"> <em>20 min</em> read</span></div></div></div><div class="post-content"><h1 id="a-complete-guide-to-memory-management-in-c">A Complete Guide to Memory Management in C++</h1><h3 id="introduction-the-power-and-responsibility-of-c"><span class="mr-2">Introduction: The Power and Responsibility of C++</span><a href="#introduction-the-power-and-responsibility-of-c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>As C++ creator Bjarne Stroustrup once said, “C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do, you blow your whole leg off.” This quote perfectly captures the essence of memory management in C++.</p><p>Unlike languages with automatic garbage collection like Java or C#, which have an internal process to release memory, C++ grants the programmer direct control over memory. This control is a primary source of its power and performance, allowing for the creation of extremely fast and efficient code.</p><p>However, this control comes with the responsibility of managing resources manually. A failure to release an unused resource is called a <strong>memory leak</strong>. A leaked resource becomes unavailable for reuse <strong>by the program itself</strong>, gradually consuming memory until the process exits. Memory leaks are a common cause of bugs and instability.</p><p>This guide will equip you with the principles and modern techniques to manage memory safely and effectively in C++. The goal is to transform what can be a daunting task into a manageable and systematic one, enabling you to write C++ code that is not only powerful but also robust and safe.</p><h2 id="1-the-two-worlds-of-memory-the-stack-and-the-heap"><span class="mr-2">1. The Two Worlds of Memory: The Stack and The Heap</span><a href="#1-the-two-worlds-of-memory-the-stack-and-the-heap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A C++ program primarily uses two distinct areas of memory for its data: the <strong>Stack</strong> and the <strong>Heap</strong> (also known as the free store).</p><ol><li><strong>The Stack</strong> The stack is a highly organized and fast region of memory where data is allocated and deallocated automatically. It operates on a “Last-In, First-Out” (LIFO) principle. The stack is where local variables and function call information are stored. When a function is called, its variables are “pushed” onto the stack; when the function exits, they are automatically “popped” off. Its primary limitation is its fixed and relatively small size.<li><strong>The Heap</strong> The heap is a large, less organized pool of memory available for data that needs to have a long lifetime or is too large to fit on the stack. Unlike the stack, memory on the heap must be allocated and deallocated <em>manually</em> by the programmer using the <code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">delete</code> operators. While flexible, this manual control is where most memory management errors occur.</ol><p>The following table synthesizes the key differences between these two memory regions.</p><div class="table-wrapper"><table><thead><tr><th>Feature<th>The Stack<th>The Heap (Free Store)<tbody><tr><td><strong>Allocation/Deallocation</strong><td>Automatic (managed by the compiler)<td>Manual (managed by the programmer via <code class="language-plaintext highlighter-rouge">new</code>/<code class="language-plaintext highlighter-rouge">delete</code>)<tr><td><strong>Speed</strong><td>Fast allocation and deallocation<td>Slower due to more complex management<tr><td><strong>Size</strong><td>Fixed and limited in size (~2MB)<td>Large and flexible<tr><td><strong>Management</strong><td>Managed by the compiler/runtime (via function calls)<td>Handled by the programmer and memory manager<tr><td><strong>Risk</strong><td>Low risk of errors<td>Prone to errors like fragmentation and leaks</table></div><p>It is important to note that the actual physical location of these two areas of memory is ultimately the same, the RAM.</p><p><em>Understanding the difference between the stack and the heap is fundamental, as the most common and dangerous errors arise from mismanaging the heap.</em></p><h2 id="2-the-perils-of-manual-memory-management"><span class="mr-2">2. The Perils of Manual Memory Management</span><a href="#2-the-perils-of-manual-memory-management" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>C-style or “naive” C++ approaches to memory management are a frequent source of bugs. A common but unreliable approach is the “Sandwich Pattern,” where a call to <code class="language-plaintext highlighter-rouge">new</code> is followed by some working code and then a corresponding call to <code class="language-plaintext highlighter-rouge">delete</code>. This pattern is insidious because it offers no guarantee that the <code class="language-plaintext highlighter-rouge">delete</code> statement will ever be reached — an exception or a premature loop exit can easily cause it to be skipped, leading to a memory leak.</p><h3 id="21-memory-leaks-the-silent-resource-drain"><span class="mr-2">2.1. Memory Leaks: The Silent Resource Drain</span><a href="#21-memory-leaks-the-silent-resource-drain" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A memory leak occurs when heap-allocated memory is no longer needed by the program but is not released back to the operating system with <code class="language-plaintext highlighter-rouge">delete</code>. This memory becomes unusable for the remainder of the program’s execution, slowly draining available resources.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">cause_a_leak</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Memory is allocated for an integer on the heap.</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">leaky_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

    <span class="c1">// The function returns, but `delete leaky_ptr;` was never called.</span>
    <span class="c1">// The pointer `leaky_ptr` is gone, but the memory it pointed to is now lost.</span>
<span class="p">}</span> <span class="c1">// Memory leak occurs here.</span>
</pre></table></code></div></div><h3 id="22-dangling-pointers-touching-freed-memory"><span class="mr-2">2.2. Dangling Pointers: Touching Freed Memory</span><a href="#22-dangling-pointers-touching-freed-memory" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A dangling pointer is a pointer that continues to point to a memory location that has already been deallocated (freed via <code class="language-plaintext highlighter-rouge">delete</code>). Attempting to access or use a dangling pointer leads to <strong>undefined behavior</strong>, which can manifest as corrupted data, unexpected crashes, or security vulnerabilities.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">create_dangling_pointer</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">dangling_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="c1">// The memory is freed.</span>
    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="c1">// `dangling_ptr` now points to deallocated memory.</span>
    <span class="c1">// Using it here is dangerous and results in undefined behavior.</span>
    <span class="c1">// *dangling_ptr = 100; // CRASH! Or worse...</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="23-double-free-deleting-twice"><span class="mr-2">2.3. Double Free: Deleting Twice</span><a href="#23-double-free-deleting-twice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A double free error occurs when the program attempts to <code class="language-plaintext highlighter-rouge">delete</code> the same memory location more than once. This action also leads to undefined behavior and can corrupt the internal data structures that the heap manager uses to track memory, often leading to a crash.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">cause_double_free</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="c1">// Attempting to delete the same memory again is a serious error.</span>
    <span class="c1">// delete ptr; // Undefined behavior!</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="24-buffer-overruns--underruns-out-of-bounds"><span class="mr-2">2.4. Buffer Overruns &amp; Underruns: Out of Bounds</span><a href="#24-buffer-overruns--underruns-out-of-bounds" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>C++ does not have built-in range checking for raw arrays. This means it is possible to write or read past the allocated boundaries of an array, an error known as an “invalid write” or “invalid read.” This is a major source of security vulnerabilities, as it can be exploited to overwrite critical program data or execute arbitrary code.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">buffer_overrun</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Allocate a heap array for 10 integers (indices 0 through 9).</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

    <span class="c1">// This loop writes one element past the end of the array.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Off-by-one error: should be i &lt; 10</span>
        <span class="c1">// On the last iteration (i=10), we write out of bounds.</span>
        <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// Invalid write!</span>
    <span class="p">}</span>

    <span class="k">delete</span><span class="p">[]</span> <span class="n">numbers</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="25-heap-fragmentation-the-checkerboard-of-memory"><span class="mr-2">2.5. Heap Fragmentation: The Checkerboard of Memory</span><a href="#25-heap-fragmentation-the-checkerboard-of-memory" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>When a program performs many frequent allocations and deallocations of small objects on the heap, the memory can become fragmented. Imagine a solid block of memory that, over time, turns into a <strong>checkerboard of used and free chunks</strong>.</p><p>The primary consequence is that even if the total amount of free memory is sufficient, the program may be unable to find a single <em>contiguous</em> block large enough to satisfy a large allocation request. This can slow down an application or, in extreme cases, cause it to fail.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="c1">// Heap Fragmentation Simulation</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// We will simulate frequent allocations of small amounts of memory</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NUM_SMALL_CHUNKS</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">SMALL_SIZE</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span> <span class="c1">// Small objects like station codes</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span> <span class="n">pointers</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Step 1: Filling the heap with small chunks...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_SMALL_CHUNKS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pointers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">SMALL_SIZE</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">// Step 2: Create the "Checkerboard"</span>
    <span class="c1">// We deallocate every second chunk. This leaves holes of free memory </span>
    <span class="c1">// separated by small "islands" of still-allocated memory.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Step 2: Creating a checkerboard pattern by deallocating every other block...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_SMALL_CHUNKS</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">pointers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">pointers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> 
    <span class="p">}</span>

    <span class="c1">// Step 3: Attempt a large contiguous allocation</span>
    <span class="c1">// Total free memory is (NUM_SMALL_CHUNKS / 2) * SMALL_SIZE.</span>
    <span class="c1">// However, the largest *contiguous* block is only SMALL_SIZE.</span>
    <span class="kt">size_t</span> <span class="n">large_request</span> <span class="o">=</span> <span class="n">SMALL_SIZE</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span> 
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Step 3: Attempting to allocate a large block: "</span> <span class="o">&lt;&lt;</span> <span class="n">large_request</span> <span class="o">&lt;&lt;</span> <span class="s">" bytes...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">large_block</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">large_request</span><span class="p">];</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Success: Contiguous block found!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">large_block</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// The heap manager cannot find a single block large enough</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failure: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" - The heap is too fragmented! [2]</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Cleanup remaining pointers</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">:</span> <span class="n">pointers</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><em>These classic pitfalls demonstrate that manual memory management is fragile because it relies on the programmer to perform cleanup. Modern C++ provides a robust philosophy that solves these problems by making cleanup and .</em></p><h2 id="3-the-guiding-principle-raii-resource-acquisition-is-initialization"><span class="mr-2">3. The Guiding Principle: RAII (Resource Acquisition Is Initialization)</span><a href="#3-the-guiding-principle-raii-resource-acquisition-is-initialization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>RAII</strong> is the central pillar of modern C++ resource management. The principle is simple yet powerful: resource ownership should be tied to an object’s lifetime. This means that an object should acquire a resource in its constructor and release it in its destructor.</p><p>The RAII lifecycle works in three deterministic steps:</p><ol><li>A resource (such as heap memory, a file handle, or a network socket) is acquired in an object’s constructor.<li>The owning object is declared on the <strong>stack</strong>.<li>When the object goes out of scope (for example, at the end of a function), its destructor is <strong>automatically and guaranteed</strong> to be called. The destructor then releases the resource.</ol><p>This pattern makes resource release deterministic and automatic, ensuring that resources are properly cleaned up even if errors occur or exceptions are thrown.</p><p>Let’s look at a practical example.</p><p><strong>Before RAII (Manual Management)</strong> Here, the <code class="language-plaintext highlighter-rouge">widget</code> class manually allocates and deallocates memory, requiring an explicit destructor.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">widget</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">size</span><span class="p">];</span> <span class="c1">// 1. Acquire resource in constructor</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">widget</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 3. Release resource in destructor</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">do_something</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">functionUsingWidget</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">widget</span> <span class="n">w</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span> <span class="c1">// 2. Object is created on the stack</span>
    <span class="n">w</span><span class="p">.</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// w goes out of scope, its destructor is automatically called.</span>

</pre></table></code></div></div><p><strong>Modern C++ with RAII (Using a Smart Pointer)</strong> By using a smart pointer (<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>), we delegate memory ownership to a dedicated RAII object. This eliminates the need for an explicit destructor in our class, making the code simpler and safer.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// The smart pointer now owns the memory</span>
<span class="nl">public:</span>
    <span class="n">widget</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="c1">// 1. Resource is acquired</span>
    <span class="p">}</span>
    <span class="c1">// 3. No explicit destructor needed! The unique_ptr handles it.</span>
    <span class="kt">void</span> <span class="n">do_something</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">functionUsingWidget</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">widget</span> <span class="n">w</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span> <span class="c1">// 2. Object created on the stack</span>
    <span class="n">w</span><span class="p">.</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// w goes out of scope, its member `data` is automatically destroyed, releasing the memory.</span>

</pre></table></code></div></div><p><em>RAII is the philosophy, and smart pointers are the primary tool you will use to implement it for dynamically allocated memory.</em></p><h2 id="4-the-modern-toolkit-smart-pointers"><span class="mr-2">4. The Modern Toolkit: Smart Pointers</span><a href="#4-the-modern-toolkit-smart-pointers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Smart pointers are class templates provided by the C++ Standard Library. They act as wrappers around a raw pointer, automatically managing its lifetime and ensuring that the memory it points to is correctly deallocated. They are the C++ way of enforcing RAII for heap memory.</p><h3 id="41-stdunique_ptr-the-default-choice-for-exclusive-ownership"><span class="mr-2">4.1. <code class="language-plaintext highlighter-rouge"><span class="mr-2">std::unique_ptr</code>: The Default Choice for Exclusive Ownership</span><a href="#41-stdunique_ptr-the-default-choice-for-exclusive-ownership" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> maintains <strong>exclusive ownership</strong> of a heap-allocated object. This means:</p><ul><li>It cannot be copied. You can only <strong>move</strong> ownership from one <code class="language-plaintext highlighter-rouge">unique_ptr</code> to another.<li>This rule is enforced at compile time, guaranteeing that only one <code class="language-plaintext highlighter-rouge">unique_ptr</code> can own the resource at any given time.<li>It is a <strong>“zero-cost abstraction”</strong>, meaning it has no performance or memory overhead compared to a raw pointer.</ul><p>For these reasons, <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> should be your default choice for managing dynamic memory.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">use_unique_pointer</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Create a unique_ptr using std::make_unique (preferred way since C++14).</span>
    <span class="k">auto</span> <span class="n">my_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">my_ptr</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="c1">// No need to call delete. The memory is automatically freed when my_ptr goes out of scope.</span>
<span class="p">}</span> <span class="c1">// my_ptr is destroyed here.</span>

</pre></table></code></div></div><h3 id="42-stdshared_ptr-for-shared-ownership-scenarios"><span class="mr-2">4.2. <code class="language-plaintext highlighter-rouge"><span class="mr-2">std::shared_ptr</code>: For Shared Ownership Scenarios</span><a href="#42-stdshared_ptr-for-shared-ownership-scenarios" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> is used when a resource needs to be owned by <strong>multiple pointers simultaneously</strong>.</p><ul><li>It uses a technique called <strong>reference counting</strong>. It keeps a count of how many <code class="language-plaintext highlighter-rouge">shared_ptr</code> instances are pointing to the resource.<li>The resource is only deleted when the last <code class="language-plaintext highlighter-rouge">shared_ptr</code> pointing to it is destroyed, causing the reference count to drop to zero.<li><strong>Trade-off:</strong> This flexibility comes at a cost. <code class="language-plaintext highlighter-rouge">shared_ptr</code> incurs a small performance overhead for storing and atomically updating the reference count.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">use_shared_pointer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="c1">// Create a shared_ptr. Reference count is 1.</span>
        <span class="k">auto</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

        <span class="c1">// Copy the shared_ptr. Both now point to the same memory.</span>
        <span class="c1">// The reference count becomes 2.</span>
        <span class="n">ptr1</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr1</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// ptr2 goes out of scope. Reference count drops to 1. The memory is NOT deleted.</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ptr1 is still valid."</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// ptr1 goes out of scope. Reference count drops to 0. The memory is now deleted.</span>

</pre></table></code></div></div><h3 id="43-choosing-the-right-smart-pointer"><span class="mr-2">4.3. Choosing the Right Smart Pointer</span><a href="#43-choosing-the-right-smart-pointer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This table provides a clear guide for when to use each type of pointer.</p><div class="table-wrapper"><table><thead><tr><th>Pointer Type<th>Ownership Semantics<th>Performance Overhead<th>Safety<th>Primary Use Case<tbody><tr><td><strong>Raw Pointer (</strong><code class="language-plaintext highlighter-rouge">new</code><strong>/</strong><code class="language-plaintext highlighter-rouge">delete</code><strong>)</strong><td>Manual / Unclear<td>None<td>Prone to leaks and errors<td>Legacy code or low-level interaction with C APIs.<tr><td><code class="language-plaintext highlighter-rouge">std::unique_ptr</code><td><strong>Exclusive / Unique</strong><td><strong>None (Zero-cost)</strong><td><strong>High (Compile-time checks)</strong><td><strong>The default choice for all owning pointers.</strong><tr><td><code class="language-plaintext highlighter-rouge">std::shared_ptr</code><td>Shared / Reference-counted<td>Yes (Reference count)<td>High (Runtime checks)<td>For shared ownership, such as in graph data structures or implementing an Observer pattern where the lifetime of the subject and observers are not strictly nested.</table></div><p><em>Managing memory for a single thread is one challenge; ensuring safety when multiple threads are involved adds another layer of complexity.</em></p><h2 id="5-memory-in-a-multi-threaded-world"><span class="mr-2">5. Memory in a Multi-Threaded World</span><a href="#5-memory-in-a-multi-threaded-world" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Memory management becomes significantly more complex in concurrent applications because all threads in a process typically share the same heap. Without proper safeguards, this shared access can lead to chaos.</p><h3 id="51-the-ultimate-danger-data-races"><span class="mr-2">5.1. The Ultimate Danger: Data Races</span><a href="#51-the-ultimate-danger-data-races" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A <strong>data race</strong> is the most dangerous type of concurrency bug. It occurs when:</p><ol><li>Two or more threads access the <strong>same memory location</strong> concurrently.<li>At least one of the accesses is a <strong>write</strong>.<li>There is <strong>no synchronization mechanism</strong> to protect the access.</ol><p>A data race results in <strong>undefined behavior</strong>. This is not just a theoretical problem; it can lead to silent data corruption, unpredictable crashes, and other hard-to-diagnose issues.</p><h3 id="52-preventing-data-races-with-synchronization"><span class="mr-2">5.2. Preventing Data Races with Synchronization</span><a href="#52-preventing-data-races-with-synchronization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>To prevent data races, C++ provides two primary tools that ensure operations on shared memory are orderly and safe.</p><ol><li><p><code class="language-plaintext highlighter-rouge">std::mutex</code> : A mutex (short for “mutual exclusion”) acts as a lock. It ensures that only one thread can access a “critical section” of code at a time. A thread must <code class="language-plaintext highlighter-rouge">lock()</code> the mutex to enter the critical section and <code class="language-plaintext highlighter-rouge">unlock()</code> it upon exit, allowing other threads to proceed. While you can manually call <code class="language-plaintext highlighter-rouge">.lock()</code> and <code class="language-plaintext highlighter-rouge">.unlock()</code>, using a <strong>Resource Acquisition Is Initialization (RAII)</strong> helper like <code class="language-plaintext highlighter-rouge">std::lock_guard</code> ensures the mutex is always released, even if an exception occurs.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre> <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span> <span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span> <span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span> <span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>    
 <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>          <span class="c1">// The "lock"</span>
 <span class="kt">int</span> <span class="n">shared_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Shared resource</span>
    
 <span class="kt">void</span> <span class="nf">increment</span><span class="p">(</span><span class="kt">int</span> <span class="n">iterations</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// The lock_guard constructor locks the mutex.</span>
         <span class="c1">// Its destructor (at the end of the loop scope) automatically unlocks it. [6]</span>
         <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span> 
            
         <span class="c1">// --- CRITICAL SECTION START ---</span>
         <span class="n">shared_counter</span><span class="o">++</span><span class="p">;</span> 
         <span class="c1">// --- CRITICAL SECTION END ---</span>
     <span class="p">}</span>
 <span class="p">}</span>
    
 <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">increment</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
     <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">increment</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
     <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
     <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Final Counter: "</span> <span class="o">&lt;&lt;</span> <span class="n">shared_counter</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>
</pre></table></code></div></div><li><p><code class="language-plaintext highlighter-rouge">std::atomic</code> : The <code class="language-plaintext highlighter-rouge">std::atomic</code> template provides types that guarantee that operations (like reads, writes, and increments) are “atomic.” Unlike a mutex, which stops other threads, atomic operations are <strong>indivisible</strong> at the hardware level; they cannot be interrupted mid-operation [source text in prompt]. By default, atomic operations provide <strong>inter-thread synchronization</strong>, meaning a <code class="language-plaintext highlighter-rouge">store</code> in one thread synchronizes with a <code class="language-plaintext highlighter-rouge">load</code> in another.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre> <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span> <span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span> <span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>    
 <span class="c1">// std::atomic provides data-race-free access without a full lock.</span>
 <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atomic_counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    
 <span class="kt">void</span> <span class="nf">atomic_increment</span><span class="p">(</span><span class="kt">int</span> <span class="n">iterations</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// This operation is indivisible and safe from data races.</span>
         <span class="c1">// It is shorthand for atomic_counter.fetch_add(1);</span>
         <span class="n">atomic_counter</span><span class="o">++</span><span class="p">;</span> 
     <span class="p">}</span>
 <span class="p">}</span>
    
 <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">atomic_increment</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
     <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">atomic_increment</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
     <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
     <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
        
     <span class="c1">// Default load() is sequentially consistent (memory_order_seq_cst).</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Final Atomic Counter: "</span> <span class="o">&lt;&lt;</span> <span class="n">atomic_counter</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>
    
</pre></table></code></div></div></ol><p>By eliminating data races from your program, the C++ memory model guarantees <strong>sequentially consistent</strong> execution, meaning the result of your multi-threaded program will be predictable and reliable, as if the operations of all threads were executed in some single sequential order.</p><p><em>While smart pointers handle most dynamic memory needs, sometimes you need finer control over how containers like</em> <code class="language-plaintext highlighter-rouge">std::vector</code> <em>get their memory. This is the job of allocators.</em></p><h2 id="6-under-the-hood-allocators"><span class="mr-2">6. Under the Hood: Allocators</span><a href="#6-under-the-hood-allocators" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>An <strong>allocator</strong> is a component of the C++ Standard Library responsible for handling all memory allocation and deallocation requests for containers like <code class="language-plaintext highlighter-rouge">std::vector</code>, <code class="language-plaintext highlighter-rouge">std::map</code>, and <code class="language-plaintext highlighter-rouge">std::list</code>.</p><p>By default, all standard containers use <code class="language-plaintext highlighter-rouge">std::allocator</code>, which is a general-purpose allocator that simply calls the global <code class="language-plaintext highlighter-rouge">operator new</code> and <code class="language-plaintext highlighter-rouge">operator delete</code> functions. However, there are scenarios where you might want to provide a <strong>custom allocator</strong>.</p><p>There are two primary reasons for writing a custom allocator:</p><ol><li><strong>Performance:</strong> For applications that perform many frequent allocations of small amounts of memory (like in a <code class="language-plaintext highlighter-rouge">std::list</code> or <code class="language-plaintext highlighter-rouge">std::map</code>), the default allocator can be slow and lead to heap fragmentation. A custom allocator that uses a <strong>memory pool</strong> — a pre-allocated large block of memory—can serve these small requests much faster by simply handing out chunks from the pool.<li><strong>Specialized Memory:</strong> Custom allocators can encapsulate access to different types of memory, such as shared memory that needs to be accessible by multiple processes, or memory managed by a third-party garbage collector.</ol><p><em>Knowing the theory is essential, but a skilled C++ programmer also needs practical tools and habits to diagnose problems and write robust code.</em></p><h2 id="7-in-the-trenches-debugging-and-best-practices"><span class="mr-2">7. In the Trenches: Debugging and Best Practices</span><a href="#7-in-the-trenches-debugging-and-best-practices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="71-finding-leaks-and-errors-with-valgrind"><span class="mr-2">7.1. Finding Leaks and Errors with Valgrind</span><a href="#71-finding-leaks-and-errors-with-valgrind" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Valgrind</strong> is a powerful instrumentation framework for dynamically analyzing programs. Its Memcheck tool is invaluable for finding memory leaks and memory errors (like invalid reads and writes) in C++ programs.</p><p>Here is a simple step-by-step guide to using it:</p><ol><li><strong>Step 1: Compile with Debug Symbols</strong> To get meaningful output with file names and line numbers, compile your program with debug symbols using the <code class="language-plaintext highlighter-rouge">ggdb3</code> or <code class="language-plaintext highlighter-rouge">Og</code> flag.<li><strong>Step 2: Run Your Program via Valgrind</strong> Execute your program through Valgrind with flags that provide detailed leak information.<li><strong>Step 3: Interpret the Output</strong><ul><li><strong>A Clean Run:</strong> A successful run with no leaks will show a “HEAP SUMMARY”.<li><strong>A Leak Report:</strong> If a leak is detected, Valgrind will show you where the leaked memory was allocated. The backtrace points directly to the <code class="language-plaintext highlighter-rouge">new</code> or <code class="language-plaintext highlighter-rouge">malloc</code> call that is the source of the leak.</ul></ol><p><img data-src="/assets/images/Cpp/image.png" alt="image.png" data-proofer-ignore></p><blockquote><p>Resource: <a href="https://stackoverflow.com/questions/5134891/how-do-i-use-valgrind-to-find-memory-leaks">https://stackoverflow.com/questions/5134891/how-do-i-use-valgrind-to-find-memory-leaks</a></p></blockquote><h3 id="72-a-defensive-coders-checklist"><span class="mr-2">7.2. A Defensive Coder’s Checklist</span><a href="#72-a-defensive-coders-checklist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Adopting good habits is the best way to prevent memory errors before they happen.</p><ul><li><strong>Prefer Stack Allocation:</strong> If data doesn’t need to outlive the function it’s created in and isn’t excessively large, always prefer creating it on the stack. It’s faster and automatically managed.<li><strong>Embrace RAII and Smart Pointers:</strong> For all heap allocations, use <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> by default. Only use <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> when you are certain that shared ownership is a necessary part of your design.<li><strong>Trust Nothing:</strong> Never assume function arguments are valid, especially raw pointers. Always check for <code class="language-plaintext highlighter-rouge">nullptr</code> and validate inputs to prevent crashes and security exploits.<li><strong>Initialize Everything:</strong> Always initialize variables when you declare them to avoid using indeterminate, garbage values. <strong>Crucially, initialize pointers to</strong> <code class="language-plaintext highlighter-rouge">nullptr</code> <strong>so that</strong> <code class="language-plaintext highlighter-rouge">delete</code> <strong>can be safely called on them even if they never end up owning a resource.</strong> This prevents a common class of errors when cleaning up objects in complex states.<li><strong>Write “Boring” Code:</strong> Avoid being overly “clever” or tricky. Simple, readable, and direct code is easier to maintain, reason about, and is far less prone to subtle bugs. Make your solution fit the problem.<li><strong>Use Safe Wrappers:</strong> When interfacing with legacy C-style APIs that return raw pointers (e.g., from <code class="language-plaintext highlighter-rouge">malloc</code>), immediately wrap the returned pointer in an appropriate smart pointer or a custom RAII class to ensure its lifetime is managed safely.</ul><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Modern C++ has transformed memory management from a manual, error-prone chore into a safe and systematic process. By understanding and applying a few core principles, you can write code that is both highly performant and exceptionally robust.</p><p>Here are the three most important takeaways:</p><ol><li><strong>Scope is Your Garbage Collector:</strong> The RAII principle is the foundation of C++ memory safety. By tying the lifetime of a resource to a stack-based object, cleanup becomes automatic, predictable, and exception-safe.<li><strong>Smart Pointers are Your Primary Tool:</strong> <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> should be your default choice for all dynamically allocated memory. It is safe, has no overhead, and clearly communicates the exclusive ownership of a resource.<li><strong>Ownership is the Central Concept:</strong> Always be clear about which part of your code <em>owns</em> a resource and is therefore responsible for its cleanup. Modern C++ features like smart pointers are designed to make this ownership explicit and verifiable by the compiler.</ol><p>By internalizing these principles, you can confidently wield the power of C++ to build applications that are not only fast but also safe, maintainable, and correct.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blog/'>Blog</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/c/" class="post-tag no-text-decoration" >c++</a> <a href="/tags/memory/" class="post-tag no-text-decoration" >memory</a> <a href="/tags/notebooklm/" class="post-tag no-text-decoration" >notebooklm</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://www.facebook.com/sharer/sharer.php?title=Memory+Management+in+C%2B%2B+-+Bhaswanth+Ayapilla&u=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fmemory-management-cpp%2F" data-toggle="tooltip" data-placement="top" title="Instagram" target="_blank" rel="noopener" aria-label="Instagram"> <i class="fa-fw fab fa-instagram"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Memory+Management+in+C%2B%2B+-+Bhaswanth+Ayapilla&u=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fmemory-management-cpp%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fmemory-management-cpp%2F&text=Memory+Management+in+C%2B%2B+-+Bhaswanth+Ayapilla" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fmemory-management-cpp%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/intro-to-rl/">Introduction to Reinforcement Learning</a><li><a href="/posts/reinforcement-learning/">Reinforcement Learning</a><li><a href="/posts/deep-rl/">Deep Reinforcement Learning</a><li><a href="/posts/lunar-roadster-cmu/">Lunar ROADSTER</a><li><a href="/posts/cmu-blog/">Coursework at CMU</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/learning/">learning</a> <a class="post-tag" href="/tags/nnets/">nnets</a> <a class="post-tag" href="/tags/rl/">rl</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/arduino/">arduino</a> <a class="post-tag" href="/tags/computer-vision/">computer vision</a> <a class="post-tag" href="/tags/control/">control</a> <a class="post-tag" href="/tags/electronics/">electronics</a> <a class="post-tag" href="/tags/manipulators/">manipulators</a> <a class="post-tag" href="/tags/ml/">ml</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/all-about-search-algorithms/"><div class="card-body"> <em class="small" data-ts="1764518400" data-df="ll" > Nov 30, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>All About Search Algorithms</h3><div class="text-muted small"><p> In progress TO-DO: Refine RRT, RRT-Connect, RRT* POMDP Multi-robot planning Graph Search Problem Once a robot converts the environment into a discrete representation, whether by grid de...</p></div></div></a></div><div class="card"> <a href="/posts/planning-case-studies/"><div class="card-body"> <em class="small" data-ts="1764518400" data-df="ll" > Nov 30, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Case Studies of Planning and Decision-Making in Robotics</h3><div class="text-muted small"><p> In progress Autonomous Driving Mobile Manipulators Legged Robots Coverage, Mapping, and Surveyal Frontier-based Planning A frontier is any region that lies at the boundary between explored sp...</p></div></div></a></div><div class="card"> <a href="/posts/electronics/"><div class="card-body"> <em class="small" data-ts="1659024000" data-df="ll" > Jul 28, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Basic Electronics</h3><div class="text-muted small"><p> Introduction The following notes were created for Techtainment, an event that I conducted to teach the basics of electronics and programming to people who hadn’t previously explored the field of r...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/planning-case-studies/" class="btn btn-outline-primary" prompt="Older"><p>Case Studies of Planning and Decision-Making in Robotics</p></a> <a href="/posts/diffusion-flow-matching/" class="btn btn-outline-primary" prompt="Newer"><p>Diffusion and Flow Matching</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Bhaswanth-A/bhaswanth-a.github.io", "data-repo-id": "R_kgDOHu5z_w", "data-category": "General", "data-category-id": "DIC_kwDOHu5z_84C0yVx", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://github.com/Bhaswanth-A">Bhaswanth Ayapilla</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/learning/">learning</a> <a class="post-tag" href="/tags/nnets/">nnets</a> <a class="post-tag" href="/tags/rl/">rl</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/arduino/">arduino</a> <a class="post-tag" href="/tags/computer-vision/">computer vision</a> <a class="post-tag" href="/tags/control/">control</a> <a class="post-tag" href="/tags/electronics/">electronics</a> <a class="post-tag" href="/tags/manipulators/">manipulators</a> <a class="post-tag" href="/tags/ml/">ml</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-CJ97GH1VYR"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-CJ97GH1VYR'); }); </script>
