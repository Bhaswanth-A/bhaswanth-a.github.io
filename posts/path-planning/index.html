<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Path Planning" /><meta name="author" content="<author_id>" /><meta property="og:locale" content="en" /><meta name="description" content="Resources" /><meta property="og:description" content="Resources" /><link rel="canonical" href="https://bhaswanth-a.github.io//posts/path-planning/" /><meta property="og:url" content="https://bhaswanth-a.github.io//posts/path-planning/" /><meta property="og:site_name" content="Bhaswanth Ayapilla" /><meta property="og:image" content="https://bhaswanth-a.github.io//assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/thumbnail_1.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-28T21:30:00+05:30" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://bhaswanth-a.github.io//assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/thumbnail_1.jpg" /><meta property="twitter:title" content="Path Planning" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@<author_id>" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"<author_id>"},"dateModified":"2024-12-14T03:54:47+05:30","datePublished":"2023-03-28T21:30:00+05:30","description":"Resources","headline":"Path Planning","image":"https://bhaswanth-a.github.io//assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/thumbnail_1.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://bhaswanth-a.github.io//posts/path-planning/"},"url":"https://bhaswanth-a.github.io//posts/path-planning/"}</script><title>Path Planning | Bhaswanth Ayapilla</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Bhaswanth Ayapilla"><meta name="application-name" content="Bhaswanth Ayapilla"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/prfl.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Bhaswanth Ayapilla</a></div><div class="site-subtitle font-italic">Vision | Reinforcement Learning</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-user ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT ME</span> </a><li class="nav-item"> <a href="/projects/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>PROJECTS</span> </a><li class="nav-item"> <a href="/cmu/" class="nav-link"> <i class="fa-fw fas fa-school ml-xl-3 mr-xl-3 unloaded"></i> <span>CMU MRSD</span> </a><li class="nav-item"> <a href="/blog/" class="nav-link"> <i class="fa-fw fas fa-blog ml-xl-3 mr-xl-3 unloaded"></i> <span>BLOG</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/cv/" class="nav-link"> <i class="fa-fw fas fa-file ml-xl-3 mr-xl-3 unloaded"></i> <span>CURRICULUM VITAE</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-address-book ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Bhaswanth-A" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['bhaswanthayapilla','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="https://www.instagram.com/bhaswanth_a/" aria-label="instagram" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-instagram"></i> </a> <a href="https://www.linkedin.com/in/bhaswanth-a/" aria-label="linkedin" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-linkedin-in"></i> </a> <a href="https://bhaswanth-a.github.io/cv/" aria-label="cv" class="order-7" target="_blank" rel="noopener"> <i class="fas fa-file"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script> </span></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Path Planning</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Path Planning</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1680019200" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 28, 2023 </em> </span> <span> Updated <em class="" data-ts="1734128687" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Dec 13, 2024 </em> </span><div class="d-flex justify-content-between"> <span> By <em> Bhaswanth Ayapilla </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5223 words"> <em>29 min</em> read</span></div></div></div><div class="post-content"><p><a href="https://drive.google.com/drive/folders/1aieMBbykgYkurXrpAslhvecRk1wsl551?usp=share_link">Resources</a></p><p><a href="https://atsushisakai.github.io/PythonRobotics/modules/path_planning/path_planning.html">Programming</a></p><h1 id="path-planning">Path Planning</h1><p>Path planning, also known as motion planning, is the process of finding a feasible path from a starting point to a desired goal point while avoiding obstacles in between. This is a fundamental problem in robotics, automation, and computer graphics.</p><p>There are several types of algorithms used for path planning:</p><ol><li>Visibility graph algorithm: This algorithm constructs a graph of visibility between the starting point, the goal point, and all obstacles. The nodes of the graph are the starting point, goal point, and the vertices of the obstacles. The edges of the graph connect nodes that have a clear line of sight. This graph is then used to find the shortest path between the starting point and the goal point.<li>Random-exploring algorithms: These algorithms randomly sample the configuration space (the space in which the robot can move) to find a path from the starting point to the goal point. Examples of random-exploring algorithms include Rapidly-exploring Random Trees (RRT) and Probabilistic Roadmaps (PRM).<li>Optimal search algorithms: These algorithms use a search strategy to find the optimal path from the starting point to the goal point. Examples of optimal search algorithms include A* (A-star), Dijkstra’s algorithm, and Breadth-First Search (BFS). These algorithms use heuristics or cost functions to guide the search towards the goal point while minimizing the path length.</ol><p>Autonomy requires that the robot is able to plan a collision-free motion from an initial to a final posture on the basis of geometric information.</p><p>Information about the workspace geometry can be</p><ul><li>entirely known in advance, called off-line planning<li>gradually discovered by the robot, called on-line planning</ul><h1 id="discrete-planning">Discrete Planning</h1><p>They are the simplest to describe because the state space will be finite (or countably infinite) in most cases. No forms of uncertainty will be considered.</p><h2 id="formulation"><span class="mr-2">Formulation:</span><a href="#formulation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>A nonempty state space X, with finite or countably infinite set of states.<li>For each state $x \in X$, a finite action space $U(x).$<li>A state transition function $f$ that produces a state $f(x,u) \in X$ for every $x \in X$ and $u \in U(x)$. The state transition equation is given by $x’=f(x,u)$.<li>An initial state $x_I \in X.$<li>A goal set $X_G \subset X.$</ol><h2 id="general-forward-search"><span class="mr-2">General Forward Search</span><a href="#general-forward-search" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Pseudo code:</strong></p><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled.png" alt="Untitled" data-proofer-ignore></p><p>The set of alive states is stored in a priority queue, Q, for which a priority function must be specified. The only significant difference between various search algorithms is the particular function used to sort Q. Therefore, assume for now that Q is a common FIFO (First-In First-Out) queue; whichever state has been waiting the longest will be chosen when $Q.GetFirst()$ is called. Initially, Q contains the initial state $x_I$. A while loop is then executed, which terminates only when Q is empty. This will only occur when the entire graph has been explored without finding any goal states, which results in a FAILURE (unless the reachable portion of X is infinite, in which case the algorithm should never terminate). In each while iteration, the highest ranked element, x, of Q is removed. If $x$ lies in $X_G$, then it reports SUCCESS and terminates; otherwise, the algorithm tries applying every possible action, $u \in U(x)$. For each next state, x’ = f(x,u), it must determine whether x’ is being encountered for the first time. If it is unvisited, then it is inserted into Q; otherwise, there is no need to consider it because it must be either dead or already in Q.</p><h3 id="breadth-first"><span class="mr-2">Breadth First</span><a href="#breadth-first" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Breadth-First Forward Search (BFS) is a graph traversal algorithm that systematically explores all the vertices (or nodes) of a graph in a breadth-first order, i.e., visiting all nodes at the same level before moving on to the next level.</p><p>The algorithm starts by visiting the root node (or starting node) and then visits all the nodes at the next level before moving on to the nodes at the next level, and so on until all nodes have been visited. It uses a FIFO queue data structure to keep track of the nodes that have been visited but whose neighbors have not yet been visited. The queue is initialized with the root node, and the algorithm iteratively dequeues a node, visits all its neighbors, and enqueues them if they have not been visited before.</p><p>The time complexity of BFS is $O(V+E)$, where V is the number of vertices (nodes) in the graph, and E is the number of edges. This is because the algorithm visits each node and each edge at most once. Also, $V=X, E=UX$ if the same actions U are available from every state. It is systematic. The worst-case performance of BFS is worse than that of A* and dynamic programming.</p><p><strong>Pseudo code:</strong></p><ol><li>Initialise a queue data structure with the root node.<li>Mark the root node as visited.<li>Dequeue a node from the queue and visit it.<li>Enqueue all the unvisited neighbors of the node.<li>Mark all the enqueued neighbours as visited.<li>Repeat steps 3-5 until the queue is empty.</ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">function</span> <span class="n">BFS</span><span class="p">(</span><span class="n">start_node</span><span class="p">)</span><span class="o">:</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>  <span class="c1">// Initialize a queue</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">start_node</span><span class="p">)</span>  <span class="c1">// Enqueue the start node</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">set</span><span class="p">()</span>  <span class="c1">// Initialize a set of visited nodes</span>
    <span class="k">while</span> <span class="n">not</span> <span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="o">:</span>  <span class="c1">// While the queue is not empty</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">dequeue</span><span class="p">()</span>  <span class="c1">// Dequeue the next node</span>
        <span class="k">if</span> <span class="n">node</span> <span class="n">not</span> <span class="n">in</span> <span class="n">visited</span><span class="o">:</span>  <span class="c1">// If the node has not been visited</span>
            <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>  <span class="c1">// Mark the node as visited</span>
            <span class="c1">// Process the node (e.g., print its value)</span>
            <span class="n">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1">// Enqueue all unvisited neighbors of the node</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="n">in</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">:</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="n">not</span> <span class="n">in</span> <span class="n">visited</span><span class="o">:</span>
                    <span class="n">Q</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="depth-first"><span class="mr-2">Depth First</span><a href="#depth-first" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Depth First Forward Search (DFS) is a graph traversal algorithm that explores the vertices of a graph in a depth-first manner, starting from a given source vertex, and visiting all the vertices reachable from it.</p><p>The DFS algorithm can be implemented using a LIFO stack data structure to keep track of the vertices being explored. When a vertex is visited, it is pushed onto the stack, and its unvisited neighbours are added to the stack in the order in which they are encountered. When there are no more unvisited neighbours, the vertex at the top of the stack is popped off and the algorithm backtracks to the previous vertex.</p><p>The time complexity of DFS algorithm is $O(V+E)$, where V is the number of vertices in the graph and E is the number of edges. The space complexity of the algorithm is O(V) due to the stack used to keep track of the visited vertices. It is systematic. The search could easily focus on one direction and completely miss large portions of the search space as the number of iterations tends to infinity.</p><p><strong>Pseudo code:</strong></p><ol><li>Start at the source vertex.<li>Mark the source vertex as visited.<li>Explore each unvisited neighbor of the source vertex in depth-first order.<li>When there are no more unvisited neighbors, backtrack to the previous vertex and repeat step 3 for its unvisited neighbors.<li>Continue this process until all reachable vertices have been visited.</ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="n">function</span> <span class="n">depthFirstForwardSearch</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span><span class="o">:</span>
    <span class="c1">// Initialize a stack for DFS traversal and a set to keep track of visited vertices</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Set</span><span class="p">()</span>

    <span class="c1">// Push the source vertex onto the stack and mark it as visited</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">not</span> <span class="n">stack</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">()</span><span class="o">:</span>
        <span class="c1">// Pop the top vertex from the stack and print it</span>
        <span class="n">currentVertex</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">print</span> <span class="n">currentVertex</span>

        <span class="c1">// Explore the neighbors of the current vertex</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="n">in</span> <span class="n">graph</span><span class="p">.</span><span class="n">getNeighbors</span><span class="p">(</span><span class="n">currentVertex</span><span class="p">)</span><span class="o">:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="n">not</span> <span class="n">in</span> <span class="n">visited</span><span class="o">:</span>
                <span class="c1">// Push the neighbor onto the stack and mark it as visited</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="best-first"><span class="mr-2">Best First</span><a href="#best-first" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Best First search is a heuristic search algorithm that is used to find the optimal path between two points in a graph. The algorithm expands the node with the lowest heuristic value first, i.e., the node that appears to be the closest to the goal. The search starts from the initial state and moves towards the goal state. It uses a heuristic function h(n) to evaluate the distance between a node n and the goal state. The algorithm maintains a priority queue (or a heap) of the nodes to be expanded, with the node with the lowest heuristic value at the front of the queue. It is not systematic.</p><p><strong>Pseudo code:</strong></p><ol><li>Initialise the open list with the start node as the only element.<li>Initialise the closed list as an empty set.<li>While the open list is not empty, do the following:<ul><li>Remove the node with the lowest heuristic value from the open list.<li>If the removed node is the goal node, return the path.<li>Otherwise, expand the node by generating all its neighbouring nodes.<li>For each neighbouring node, calculate its heuristic value h(n) and add it to the open list if it is not already in the closed list or the open list.<li>Add the expanded node to the closed list.</ul><li>If the open list becomes empty and the goal node is not found, return failure.</ol><h3 id="iterative-deepening"><span class="mr-2">Iterative Deepening</span><a href="#iterative-deepening" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Iterative Deepening Algorithm (IDA) is a general search algorithm based on depth-first search (DFS), but unlike DFS, IDA performs multiple iterations, each with increasing depth limits. The algorithm starts with a depth limit of one and iteratively increases it until the goal is found.</p><p>The iterative deepening algorithm uses a breadth-first search-like strategy to incrementally search the space by exploring each level of the search tree. The algorithm starts by searching the tree at a depth limit of one. If the goal is not found, the algorithm increases the depth limit to two and searches the tree again. This process is repeated until the goal is found.</p><p>The iterative deepening algorithm is often used in cases where the search space is too large for a complete search. By limiting the search depth, the algorithm can focus on the most promising parts of the search space, while still being able to find the optimal solution. The time complexity of IDA is O(b^d), where b is the branching factor and d is the depth of the goal node. The space complexity of the algorithm is O(d). It has better worst-case performance than BFS. Furthermore, the space requirements are reduced because the queue in BFS is usually much larger than for DFS.</p><h1 id="combinatorial-motion-planning">Combinatorial Motion Planning</h1><p><a href="https://youtu.be/Y5_aHsqX22s">Roadmap Based Path Planning: Visibility Graph and Generalised Voronoi Diagrams as roadmaps</a></p><p>Covers visibility graphs and voronoi diagrams.</p><p>Combinatorial motion planning is a subfield of robotics and artificial intelligence that focuses on developing algorithms and techniques for planning the motion of robots in complex environments. The goal is to find feasible paths that enable robots to reach their desired goals while avoiding obstacles and adhering to various constraints.</p><p>Unlike continuous motion planning, which deals with continuous trajectories, combinatorial motion planning involves searching through a discrete set of possible motions and selecting the optimal one. This involves exploring the space of all possible robot configurations and determining which configurations can be reached without colliding with obstacles or violating constraints.</p><p>Some common techniques used in combinatorial motion planning include graph-based search algorithms, sampling-based planners, and cell decomposition methods. These techniques leverage computational tools and mathematical models to efficiently plan the motion of robots and ensure they operate safely and effectively.</p><h2 id="continuous-motion-planning-methods"><span class="mr-2">Continuous Motion Planning Methods</span><a href="#continuous-motion-planning-methods" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Continuous motion planning methods are algorithms and techniques used to plan the continuous motion of robots in complex environments. Unlike combinatorial motion planning, which deals with a discrete set of possible motions, continuous motion planning deals with continuous trajectories.</p><p>Continuous motion planning methods use mathematical models and algorithms to determine optimal trajectories that enable robots to reach their desired goals while avoiding obstacles and adhering to various constraints. These methods often involve the use of calculus and optimization techniques to find the optimal path.</p><p>They are often more computationally intensive than combinatorial motion planning methods. This is because they involve solving complex mathematical equations and optimizing continuous functions. However, they offer greater flexibility and precision in planning robot motion, enabling robots to operate more efficiently and effectively in complex environments.</p><p>Examples of continuous motion planning techniques include:</p><ol><li>Trajectory optimization: This method involves finding the optimal trajectory for a robot by solving an optimization problem that minimizes a cost function. The cost function can be customized to include constraints on the robot’s motion, such as collision avoidance or energy consumption. Trajectory optimization can be solved using numerical optimization techniques, such as gradient descent or nonlinear programming.<li>Control-based planning: This method involves using a control law to steer the robot along a desired trajectory. The control law can be designed using various techniques, such as feedback linearization or model predictive control. Control-based planning can be used to plan the motion of robots in dynamic environments, where the robot’s motion must be continuously updated in response to changing conditions.<li>Model predictive control (MPC): MPC is a control-based planning method that involves predicting the future behavior of the robot and optimizing its motion accordingly. MPC uses a dynamic model of the robot and the environment to predict how the robot’s motion will affect its surroundings, and it optimizes the robot’s motion to achieve a desired goal while satisfying various constraints.<li>Sampling-based planning: This method involves randomly sampling the robot’s configuration space to generate a set of feasible trajectories. The set of trajectories is then pruned to remove those that collide with obstacles or violate constraints. Sampling-based planning is computationally efficient and can be used to plan the motion of robots in high-dimensional spaces, but it may not always find the optimal trajectory.</ol><h2 id="roadmaps"><span class="mr-2">Roadmaps</span><a href="#roadmaps" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Roadmaps in combinatorial motion planning refer to a set of interconnected nodes and edges that are constructed in the configuration space of a robot or a group of robots. The configuration space represents all possible configurations of the robot(s) in the environment, including their position, orientation, and other relevant parameters.</p><p>The roadmap construction process involves sampling the configuration space and identifying collision-free configurations that can be used as nodes in the roadmap. These nodes are then connected by edges that represent feasible paths between them. The resulting roadmap provides a discrete representation of the configuration space and enables efficient path planning for the robot(s).</p><p>There are several types of roadmaps that can be used in combinatorial motion planning, including probabilistic roadmaps (PRMs), visibility graphs, and cell decomposition-based roadmaps. Each type has its strengths and weaknesses, and the choice of roadmap depends on the specific application and requirements.</p><p>There are many roadmap-based approaches, and they primarily fall into 3 categories:</p><ol><li>Topological Model - Every location is represented by a node, which are connected by edges.<li>Geometrical Model - The geometry of the environment, containing obstacles, is considered and a free space, which is a collection of all free configurations that do not collide with the obstacles, is created.<li>Grid-based Model - The entire environment is divided in cells or grids and based on the connectivity between these grids, roadmaps are created.</ol><p><strong>Formal definition:</strong> A union of one dimensional curves R is a roadmap if for all starting positions q and goal positions g, that can be connected by a path, the following properties hold -</p><ul><li>Accessibility - There exists a path from q to some point q’ on R<li>Departability - There exists a path from a point g’ on R to g<li>Connectivity - There exists a path in R from q’ to g’</ul><h2 id="visibility-graph"><span class="mr-2">Visibility Graph</span><a href="#visibility-graph" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://www.usna.edu/Users/cs/crabbe/SI475/current/simple-model/path_planning/voronoi.pdf"></a></p><p>The visibility graph is a method used to represent the connectivity of a configuration space. A configuration space is the space that represents all possible positions and orientations of a robot or object.</p><p>The basic idea is that if we stretched a rubber band from start to target, weaving in and out of the obstacles, the band would form a straight line between the obstacles, and would wrap around the obstacles themselves.</p><p>The visibility graph is constructed by first placing a node at each obstacle boundary and at the starting and ending configurations of the robot. Then, an edge is added between two nodes if the line segment connecting them does not intersect any obstacle boundaries. This process creates a graph that represents all possible paths that the robot can take without colliding with any obstacles. Its edges are the edges of the obstacles and edges joining all pairs of vertices that can see each other.</p><p>It is based on the principle that given a start point and a goal point, we look for all vertices of obstacles present in the environment which are visible from the given start location. We then traverse through those vertices to reach the destination in the shortest path.</p><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled%201.png" alt="Start, goal, vertices of obstacles are graph nodes. Edges are “visible” connections between nodes, including obstacle edges." data-proofer-ignore></p><p>Start, goal, vertices of obstacles are graph nodes. Edges are “visible” connections between nodes, including obstacle edges.</p><h3 id="reduced-visibility-graph"><span class="mr-2">Reduced Visibility Graph</span><a href="#reduced-visibility-graph" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A reduced visibility graph consists of very few edges to reduce its complexity. It makes use of supporting and separating lines.</p><ul><li>Supporting lines are edges in the visibility graph that connect two vertices on the boundary of the same obstacle. <strong>The obstacles lie on the same side of the supporting lines.</strong> These edges are important because they represent the possibility of the robot following a path along the boundary of an obstacle without colliding with it. Supporting lines can be used to construct a continuous path for the robot along the boundary of an obstacle, which is useful in situations where the robot cannot pass through the obstacle.<li>Separating lines, on the other hand, are edges in the visibility graph that connect two vertices on the boundaries of different obstacles. <strong>The obstacles lie on opposite sides of the separating lines.</strong> These edges represent the possibility of the robot moving between two obstacles without colliding with either one. Separating lines are important because they define the regions of the configuration space that are accessible to the robot, and can be used to divide the configuration space into different regions, each of which can be explored separately.</ul><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled%202.png" alt="Untitled" data-proofer-ignore></p><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled%203.png" alt="Neither supporting nor separating since they cut through the obstacles. They are avoided in constructing visibility graphs." data-proofer-ignore></p><p>Neither supporting nor separating since they cut through the obstacles. They are avoided in constructing visibility graphs.</p><h3 id="rotational-plane-sweep-algorithm"><span class="mr-2">Rotational Plane Sweep Algorithm</span><a href="#rotational-plane-sweep-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>It is used for constructing a visibility graph for a set of obstacles in a configuration space. The algorithm works by sweeping a ray around the configuration space and adding edges to the visibility graph whenever the ray intersects an obstacle boundary.</p><ul><li>Input: A set of vertices ${v_i}$(whose edges do not intersect) and a vertex v.<li>Output: A subset of vertices from ${v_i}$ that are within the line of sight of v.</ul><p><strong>Pseudo code:</strong></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">FOR</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">calculate</span> <span class="n">alpha</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">NEW</span> <span class="n">vertexSet</span> <span class="o">=</span> <span class="n">set</span> <span class="n">of</span> <span class="n">alpha</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">which</span> <span class="n">are</span> <span class="n">increasing</span> <span class="n">order</span>
<span class="n">NEW</span> <span class="n">activeSet</span> <span class="o">=</span> <span class="n">set</span> <span class="n">of</span> <span class="n">edge</span> <span class="n">which</span> <span class="n">intersect</span> <span class="n">the</span> <span class="n">horizontal</span> <span class="n">half</span> <span class="n">line</span> <span class="n">emanating</span> <span class="n">from</span> <span class="n">v</span>
<span class="n">FOR</span> <span class="n">all</span> <span class="n">alpha</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
	<span class="n">IF</span> <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">is</span> <span class="n">visible</span> <span class="n">v</span>
		<span class="n">THEN</span> <span class="n">visibleSet</span><span class="p">.</span><span class="n">PUSH</span><span class="p">(</span><span class="n">edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
	<span class="n">ENDIF</span>
	<span class="n">IF</span> <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">is</span> <span class="n">the</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">an</span> <span class="n">edge</span><span class="p">,</span> <span class="n">vertexSet</span><span class="p">,</span> <span class="n">not</span> <span class="n">in</span> <span class="n">activeSet</span>
		<span class="n">THEN</span> <span class="n">activeSet</span><span class="p">.</span><span class="n">PUSH</span><span class="p">(</span><span class="n">vertexSet</span><span class="p">)</span>
	<span class="n">ENDIF</span>
	<span class="n">IF</span> <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">is</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">an</span> <span class="n">edge</span> <span class="n">in</span> <span class="n">activeSet</span>
		<span class="n">THEN</span> <span class="n">activeSet</span><span class="p">.</span><span class="n">DELETE</span><span class="p">(</span><span class="n">edge</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">v</span><span class="p">))</span>
	<span class="n">ENDIF</span>
<span class="n">ENDFOR</span>
</pre></table></code></div></div><p>Once the visibility graph is built, then robot starts to find the path among visibility graph. Since the visibility map posses the properties of accessibility and departability by definition, if it is connected, then several kinds of searching algrithm can be implemented such as potential function and various star algorithm. Cost between nodes can be set to distance of nodes and heuristic cost function can be set to estimated cost of shortest path from node to goal.</p><p>The shortest path being computed tries to stay as close as possible to the obstacles. Any execution error will lead to a collision. It also becomes more complex in higher dimensions.</p><h2 id="cell-decomposition"><span class="mr-2">Cell Decomposition</span><a href="#cell-decomposition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Cell decomposition is a technique used in combinatorial motion planning to divide the workspace into smaller regions, called cells, that can be easily navigated by a robot. Each cell is defined as a region that is either free of obstacles or contains a single obstacle.</p><p>The process of cell decomposition involves dividing the workspace into a grid of cells, where each cell is either classified as free or occupied by an obstacle. This grid can then be used to represent the workspace as a graph, where the cells are the nodes and the edges connect adjacent cells.</p><p>One advantage of cell decomposition is that it simplifies the motion planning problem by reducing it to a discrete search problem. It also allows for the use of graph-based algorithms, such as Dijkstra’s algorithm or A*, to find a path from the starting cell to the goal cell.</p><p>There are several types of cell decomposition techniques, including:</p><ol><li>Voronoi Diagrams: These are diagrams that divide the workspace into regions based on the distance to the obstacles. The cells in a Voronoi diagram represent the regions of the workspace that are closest to a particular obstacle.<li>Binary Space Partitioning (BSP): This technique divides the workspace into two subspaces recursively, with each subspace divided by a line or plane. This creates a tree structure where each node represents a subspace and each leaf node represents a single cell.<li>Quadtree Decomposition: This technique recursively divides the workspace into four quadrants, with each quadrant further subdivided until each cell contains at most one obstacle.</ol><h2 id="voronoi-diagram"><span class="mr-2">Voronoi Diagram</span><a href="#voronoi-diagram" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Voronoi diagrams are a geometric structure that partition a space into a set of regions based on the distance to a given set of points or objects. In the context of motion planning, Voronoi diagrams can be used to represent the free space and obstacles in a configuration space, and to compute paths or trajectories for a robot navigating through that space.</p><p>The Voronoi diagram for a set of points in a space consists of a set of cells, where each cell represents the region of space that is closest to a particular point or object. The cells are defined by a set of lines or curves, called the Voronoi edges, which are equidistant from the neighboring points or objects. The Voronoi diagram is often visualized as a set of polygonal cells that cover the entire space, with the edges of the cells corresponding to the Voronoi edges.</p><h3 id="generalized-voronoi-diagrams"><span class="mr-2">Generalized Voronoi Diagrams</span><a href="#generalized-voronoi-diagrams" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://www.usna.edu/Users/cs/crabbe/SI475/current/simple-model/path_planning/voronoi.pdf"></a></p><p><a href="https://www.cs.columbia.edu/~pblaer/projects/path_planner/">Robot Path Planning Using Generalized Voronoi Diagrams.</a></p><p>The obstacles in the real world are never points but they’re large objects. Generalized Voronoi Diagrams are just like regular VDs, but instead of the regions around points, we have the regions around objects.</p><p><a href="https://youtu.be/YBq_fzAOpVI">Generalized Voronoi Graph</a></p><p><a href="https://medium.com/analytics-vidhya/create-voronoi-regions-with-python-28720b9c70d8">Create Voronoi regions with Python</a></p><h3 id="vertical-strip-cell-decomposition"><span class="mr-2">Vertical Strip Cell Decomposition</span><a href="#vertical-strip-cell-decomposition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>The cells joining the start and target are shaded.<li>The resolution of the decomposition is chosen to get a collision-free path dependent on the sensitivity of controlling robot’s motion.</ul><h3 id="planning"><span class="mr-2">Planning</span><a href="#planning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled%204.png" alt="Untitled" data-proofer-ignore></p><ul><li>Find the point \(q*_{start}\) of the Voronoi diagram closest to \(q_{start}\).<li>Find the point \(q*_{goal}\) of the Voronoi diagram closest to \(q_{goal}\).<li>Compute the shortest path from \(q*_{start}\) to \(q*_{goal}\) on the Voronoi diagram.</ul><h1 id="sampling-based-motion-planning">Sampling based Motion Planning</h1><p>The state space for motion planning, C, is uncountably infinite. Yet a sampling based planning algorithm can consider at most a countable number of samples.</p><h2 id="single-query-and-multi-query-planning"><span class="mr-2">Single Query and Multi Query Planning</span><a href="#single-query-and-multi-query-planning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Multi-query path planning and single-query path planning are two different types of path planning algorithms used in robotics and computer science.</p><p>Single-query path planning refers to finding a path between two given points in a given environment, where the start and end points are fixed and do not change. In other words, it is the process of finding a path from a single source to a single destination in a given environment. This is a common problem in robotics, where robots need to navigate from one point to another without colliding with obstacles. It is only concerned about a portion of free C-space needed for a query.</p><p>On the other hand, multi-query path planning refers to finding paths between multiple pairs of points in a given environment. Unlike single-query path planning, in multi-query path planning, the start and end points can vary from one query to another. For example, a robot may need to navigate to different locations in a warehouse to pick up items, and the start and end points will change with each new task. Th goal is to efficiently model the entire C-space so as to answer any query in that space. Example - Probabilistic Roadmap (PRM)</p><p>Multi-query path planning is more complex than single-query path planning, as it requires the algorithm to efficiently handle multiple queries and avoid recalculating the entire path for each new query. However, it can be more efficient in situations where there are multiple tasks to be completed in the same environment.</p><p>Probabilistic Roadmap of Tree (PRT) combines both ideas.</p><h2 id="probabilistic-roadmap-prm"><span class="mr-2">Probabilistic Roadmap (PRM)</span><a href="#probabilistic-roadmap-prm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://www.cs.columbia.edu/~allen/F15/NOTES/Probabilisticpath.pdf"></a></p><p>It is a randomized algorithm that is designed to efficiently find collision-free paths for robots in complex environments. PRM algorithm involves the following components:</p><ol><li>Roadmap construction: The first step of PRM is to construct a roadmap of the environment. This is done by randomly sampling configurations of the robot in the environment and checking whether they are collision-free. Collision-free configurations are added to the roadmap as nodes, and connections are made between nodes that are within a certain distance of each other.<ul><li><strong>Milestones:</strong> Milestones are the nodes in the roadmap that represent the important configurations of the robot in the environment. These configurations are sampled randomly from the configuration space of the robot, and they are checked for collision with the obstacles in the environment. If a configuration is collision-free, it is added as a milestone to the roadmap.<li><strong>Local paths:</strong> Local paths are the edges that connect the milestones in the roadmap. They represent the feasible paths that the robot can take between the milestones. The local paths are computed by planning a short path between each pair of milestones, while avoiding the obstacles in the environment.</ul><li>Roadmap search: The next step is to search the roadmap for a path between the start and goal configurations. The local paths are used to guide the robot along the roadmap, and the milestones serve as guideposts to ensure that the robot stays on a collision-free path. This is done using a standard graph search algorithm, such as A* search or Dijkstra’s algorithm. The algorithm tries to find the shortest path between the start and goal configurations while avoiding collisions with obstacles.<li>Path refinement: The final step is to refine the path found by the roadmap search. This is done by iteratively attempting to move along the path and checking for collisions. If a collision is detected, the path is locally modified to avoid the obstacle. This process continues until a collision-free path is found.</ol><p><strong>Features:</strong></p><ul><li>PRMs don’t represent the entire free configuration space, but rather a roadmap through it.<li>Roadmap is an undirected acyclic graph R = (N,E).<li>Nodes N are robot configurations in free C-space, called milestones.<li>Edges E represent local paths between configurations.<li>Learning Phase<ul><li>Construction: reasonably connected graph covering C-space<li>Expansion: improve connectivity<li>Local paths not memorized (cheap to re-compute)</ul></ul><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled%205.png" alt="Untitled" data-proofer-ignore></p><p><strong>Construction overview:</strong></p><ol><li>R = (N,E) begins empty<li>A random free configuration c is generated and added to N<li>Candidate neighbours to c are partitioned from N<li>Edges are created between these neighbours and c, such that acyclicity is preserved<li>Repeat 2-4 until done</ol><p><strong>General Local Planner:</strong></p><ol><li>Connect the two configurations is C-space with a straight line segment<li>Check the joint limits<li>Discretize the line segment into a sequence of configurations c1, c2, …, cm such that for every $(c_i, c_{i+1})$, no point on the robot at ci lies further than $\epsilon$ away from its position at ci+1<li>For each ci, grow robot by $\epsilon$, check for collisions</ol><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled%206.png" alt="Untitled" data-proofer-ignore></p><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled%207.png" alt="Untitled" data-proofer-ignore></p><p>Edges are created between these neighbours and c, such that acyclicity is preserved.</p><p><strong>Random Bounce Walk:</strong></p><ol><li>Pick a random direction of motion in C-space, move in this direction from c.<li>If collision occurs, pick a new direction and continue.<li>The final configuration n and the edge (c,n) are inserted into the graph.<li>Attempt to connect n to other nodes using the construction step technique.<li>Path between c and n must be stored, since process is non-deterministic.</ol><p>Select c such that P(c is selected) = w(c)</p><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled%208.png" alt="Untitled" data-proofer-ignore></p><p><strong>Query Phase:</strong></p><ul><li>Connect start and goal configurations to roadmap (say $\hat{s}$ and $\hat{g}$)<li>Find path between $\hat{s}$ and $\hat{g}$ in roadmap</ul><p><img data-src="/assets/images/Path%20Planning%20035901279cc342358ee1ff168f77dd73/Untitled%209.png" alt="Untitled" data-proofer-ignore></p><p><strong>Pros:</strong></p><ul><li>Once learning is done, queries can be executed quickly<li>Complexity reduction over full C-space representation<li>Adaptive - can incrementally build on roadmap<li>Probabilisically complete, which is usually good enough</ul><p><strong>Cons:</strong></p><ul><li>$\hat{s}$ and $\hat{g}$ should be in same connected component, else failure<li>Paths are not optimal. They can be long and indirect, depending on how the graph was created. Smoothing can be applied.</ul><h2 id="rapidly-exploring-random-tree-rrt"><span class="mr-2">Rapidly-Exploring Random Tree (RRT)</span><a href="#rapidly-exploring-random-tree-rrt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="table-wrapper"><table><tbody><tr><td>[Path Planning with A* and RRT<td>Autonomous Navigation, Part 4](https://www.youtube.com/watch?v=QR3U1dgc5RE&amp;t=45s)</table></div><p><a href="https://www.youtube.com/watch?v=Ob3BIJkQJEw">RRT, RRT* &amp; Random Trees</a></p><p>RRT is a probabilistic algorithm that builds a tree of feasible paths in the search space.</p><p>The RRT algorithm starts with an initial configuration of the robot or system being planned for, and then iteratively grows a tree by randomly selecting a new configuration, and connecting it to the closest node in the tree. The algorithm continues to grow the tree until a path is found from the initial configuration to the goal configuration, or until a certain maximum number of iterations is reached.</p><p>The random sampling and connection of nodes in RRT allows it to quickly explore large areas of the search space, making it well-suited for solving complex path planning problems in high-dimensional spaces. Additionally, RRT can handle non-holonomic constraints, as well as dynamic obstacles and changes in the environment.</p><p>RRT has several variants, including RRT* and RRT-Connect, which incorporate optimization and connectivity constraints to improve the quality of the resulting paths.</p><p>RRTs have the advantage that they expand very fast and bias towards unexplored regions of the configuration space and so covering a wide area in a reduced time.</p><p>When one of the leaves of the tree reaches a goal region, the algorithm stops and a path can directly be found by following the predecessors of the last added node.</p><p><strong>Features:</strong></p><ul><li>It is implemented using tree data structure<li>Tree is special case of directed graph<li>Edges are directed from child node to parent<li>Every node has one parent, except root<li>Nodes represent physical states or configurations<li>Edges represent feasible paths between states<li>Each edge has cost associated traversing feasible path</ul><p><strong>Pseudo code:</strong></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="mi">1</span><span class="p">.</span> <span class="n">Initialize</span> <span class="n">tree</span> <span class="n">T</span> <span class="n">with</span> <span class="n">a</span> <span class="n">single</span> <span class="n">node</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">state</span> <span class="n">S</span>
<span class="mi">2</span><span class="p">.</span> <span class="k">while</span> <span class="n">not</span> <span class="n">goal_found</span> <span class="n">and</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="n">max_iterations</span> <span class="k">do</span>
<span class="mi">3</span><span class="p">.</span>     <span class="n">randomly</span> <span class="n">sample</span> <span class="n">a</span> <span class="n">new</span> <span class="n">configuration</span> <span class="n">Q</span>
<span class="mi">4</span><span class="p">.</span>     <span class="n">find</span> <span class="n">the</span> <span class="n">node</span> <span class="n">N</span> <span class="n">in</span> <span class="n">T</span> <span class="n">that</span> <span class="n">is</span> <span class="n">closest</span> <span class="n">to</span> <span class="n">Q</span>
<span class="mi">5</span><span class="p">.</span>     <span class="n">extend</span> <span class="n">the</span> <span class="n">tree</span> <span class="n">from</span> <span class="n">N</span> <span class="n">towards</span> <span class="n">Q</span> <span class="n">by</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">distance</span> <span class="n">delta_q</span>
<span class="mi">6</span><span class="p">.</span>     <span class="k">if</span> <span class="n">Q</span> <span class="n">is</span> <span class="n">within</span> <span class="n">delta_q</span> <span class="n">of</span> <span class="n">the</span> <span class="n">goal</span> <span class="n">state</span> <span class="n">G</span><span class="p">,</span> <span class="n">add</span> <span class="n">a</span> <span class="n">node</span> <span class="n">at</span> <span class="n">Q</span> <span class="n">and</span> <span class="n">goal_found</span> <span class="o">=</span> <span class="nb">true</span>
<span class="mi">7</span><span class="p">.</span>     <span class="n">iterations</span> <span class="o">=</span> <span class="n">iterations</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">8</span><span class="p">.</span> <span class="k">return</span> <span class="n">the</span> <span class="n">path</span> <span class="n">from</span> <span class="n">S</span> <span class="n">to</span> <span class="n">G</span> <span class="k">if</span> <span class="n">goal_found</span><span class="p">,</span> <span class="n">otherwise</span> <span class="k">return</span> <span class="n">failure</span>
</pre></table></code></div></div><p>In the above pseudocode, <strong><code class="language-plaintext highlighter-rouge">T</code></strong> represents the tree of feasible paths, <strong><code class="language-plaintext highlighter-rouge">S</code></strong> is the initial state, <strong><code class="language-plaintext highlighter-rouge">G</code></strong> is the goal state, and <strong><code class="language-plaintext highlighter-rouge">delta_q</code></strong> is a parameter that controls the maximum distance the algorithm can extend from the current node. The algorithm iteratively adds nodes to the tree <strong><code class="language-plaintext highlighter-rouge">T</code></strong> until either a path from <strong><code class="language-plaintext highlighter-rouge">S</code></strong> to <strong><code class="language-plaintext highlighter-rouge">G</code></strong> is found, or the maximum number of iterations is reached.</p><h1 id="a-algorithm">A* Algorithm</h1><p><a href="https://www.youtube.com/watch?v=-L-WgKMFuhE">A* Pathfinding (E01: algorithm explanation)</a></p><h1 id="dijkstras-algorithm">Dijkstra’s Algorithm</h1><p><a href="https://youtu.be/GazC3A4OQTE">Dijkstra’s Algorithm - Computerphile</a></p><p><a href="https://youtu.be/EFg3u_E6eHU">How Dijkstra’s Algorithm Works</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blog/'>Blog</a>, <a href='/categories/robotics/'>Robotics</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/planning/" class="post-tag no-text-decoration" >planning</a> <a href="/tags/astar/" class="post-tag no-text-decoration" >astar</a> <a href="/tags/dijkstra/" class="post-tag no-text-decoration" >dijkstra</a> <a href="/tags/search/" class="post-tag no-text-decoration" >search</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://www.facebook.com/sharer/sharer.php?title=Path+Planning+-+Bhaswanth+Ayapilla&u=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fpath-planning%2F" data-toggle="tooltip" data-placement="top" title="Instagram" target="_blank" rel="noopener" aria-label="Instagram"> <i class="fa-fw fab fa-instagram"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Path+Planning+-+Bhaswanth+Ayapilla&u=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fpath-planning%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fpath-planning%2F&text=Path+Planning+-+Bhaswanth+Ayapilla" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fpath-planning%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cmu-blog/">Coursework at CMU</a><li><a href="/posts/lunar-roadster-cmu/">Lunar ROADSTER</a><li><a href="/posts/learning-3d-vision-25/">Learning for 3D Vision</a><li><a href="/posts/robot-autonomy-25/">Robot Autonomy</a><li><a href="/posts/intro-robotics-business-25/">Introduction to Robotics Business</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/learning/">learning</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/control/">control</a> <a class="post-tag" href="/tags/nnets/">nnets</a> <a class="post-tag" href="/tags/arduino/">arduino</a> <a class="post-tag" href="/tags/computer-vision/">computer vision</a> <a class="post-tag" href="/tags/electronics/">electronics</a> <a class="post-tag" href="/tags/rl/">rl</a> <a class="post-tag" href="/tags/simulation/">simulation</a> <a class="post-tag" href="/tags/matlab/">matlab</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/milwaukee-tool/"><div class="card-body"> <em class="small" data-ts="1749484800" data-df="ll" > Jun 9, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Milwaukee Tool</h3><div class="text-muted small"><p> In Progress Milwaukee Tool</p></div></div></a></div><div class="card"> <a href="/posts/lunar-roadster-cmu/"><div class="card-body"> <em class="small" data-ts="1733328000" data-df="ll" > Dec 4, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Lunar ROADSTER</h3><div class="text-muted small"><p> Lunar Robotic Operator for Autonomous Development of Surface Trails and Exploration Routes (ROADSTER) Supervisor: Dr. William “Red” Whittaker Team: Bhaswanth Ayapilla, Ankit Aggarwal, Deepam Amer...</p></div></div></a></div><div class="card"> <a href="/posts/deep-learning-perceptrons/"><div class="card-body"> <em class="small" data-ts="1749484800" data-df="ll" > Jun 9, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Deep Learning - Perceptrons</h3><div class="text-muted small"><p> In Progress Neural Networks Depth - length of longest path from source to sink Layer - Set of all neurons which are all at the same depth with respect to the source Gradient For a scalar functi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/chess-engine-rl/" class="btn btn-outline-primary" prompt="Older"><p>Chess Engine using Reinforcement Learning</p></a> <a href="/posts/swarm-algorithms/" class="btn btn-outline-primary" prompt="Newer"><p>Swarm Robot Tasks and Algorithms</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/Bhaswanth-A">Bhaswanth Ayapilla</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/learning/">learning</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/control/">control</a> <a class="post-tag" href="/tags/nnets/">nnets</a> <a class="post-tag" href="/tags/arduino/">arduino</a> <a class="post-tag" href="/tags/computer-vision/">computer vision</a> <a class="post-tag" href="/tags/electronics/">electronics</a> <a class="post-tag" href="/tags/rl/">rl</a> <a class="post-tag" href="/tags/simulation/">simulation</a> <a class="post-tag" href="/tags/matlab/">matlab</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-CJ97GH1VYR"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-CJ97GH1VYR'); }); </script>
