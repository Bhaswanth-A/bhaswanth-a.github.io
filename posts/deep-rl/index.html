<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Deep Reinforcement Learning" /><meta name="author" content="<author_id>" /><meta property="og:locale" content="en" /><meta name="description" content="Finite Markov Decision Process" /><meta property="og:description" content="Finite Markov Decision Process" /><link rel="canonical" href="https://bhaswanth-a.github.io//posts/deep-rl/" /><meta property="og:url" content="https://bhaswanth-a.github.io//posts/deep-rl/" /><meta property="og:site_name" content="Bhaswanth Ayapilla" /><meta property="og:image" content="https://bhaswanth-a.github.io//assets/images/ldr.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2026-02-09T11:00:00-05:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://bhaswanth-a.github.io//assets/images/ldr.png" /><meta property="twitter:title" content="Deep Reinforcement Learning" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@<author_id>" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"<author_id>"},"dateModified":"2026-02-20T20:40:50-05:00","datePublished":"2026-02-09T11:00:00-05:00","description":"Finite Markov Decision Process","headline":"Deep Reinforcement Learning","image":"https://bhaswanth-a.github.io//assets/images/ldr.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://bhaswanth-a.github.io//posts/deep-rl/"},"url":"https://bhaswanth-a.github.io//posts/deep-rl/"}</script><title>Deep Reinforcement Learning | Bhaswanth Ayapilla</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Bhaswanth Ayapilla"><meta name="application-name" content="Bhaswanth Ayapilla"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/prfl.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Bhaswanth Ayapilla</a></div><div class="site-subtitle font-italic">Perception | Reinforcement Learning</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-user ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT ME</span> </a><li class="nav-item"> <a href="/projects/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>PROJECTS</span> </a><li class="nav-item"> <a href="/cmu/" class="nav-link"> <i class="fa-fw fas fa-school ml-xl-3 mr-xl-3 unloaded"></i> <span>CMU MRSD</span> </a><li class="nav-item"> <a href="/blog/" class="nav-link"> <i class="fa-fw fas fa-blog ml-xl-3 mr-xl-3 unloaded"></i> <span>BLOG</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/cv/" class="nav-link"> <i class="fa-fw fas fa-file ml-xl-3 mr-xl-3 unloaded"></i> <span>CURRICULUM VITAE</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-address-book ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Bhaswanth-A" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['bhaswanthayapilla','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="https://www.instagram.com/bhaswanth_a/" aria-label="instagram" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-instagram"></i> </a> <a href="https://www.linkedin.com/in/bhaswanth-a/" aria-label="linkedin" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-linkedin-in"></i> </a> <a href="https://bhaswanth-a.github.io/cv/" aria-label="cv" class="order-7" target="_blank" rel="noopener"> <i class="fas fa-file"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script> </span></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Deep Reinforcement Learning</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Deep Reinforcement Learning</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1770652800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Feb 9, 2026 </em> </span> <span> Updated <em class="" data-ts="1771638050" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Feb 20, 2026 </em> </span><div class="d-flex justify-content-between"> <span> By <em> Bhaswanth Ayapilla </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="16598 words"> <em>92 min</em> read</span></div></div></div><div class="post-content"><h1 id="finite-markov-decision-process">Finite Markov Decision Process</h1><p>A Finite Markov Decision Process (MDP) is a mathematical framework used to model sequential decision-making problems where an agent interacts with an environment over time. It is defined as a tuple $(S, A, p, r, \gamma)$, where each component captures one aspect of this interaction.</p><ul><li>The state space $S$ is a finite set of all possible situations the agent can be in.<li>The action space $A$ is a finite set of choices available to the agent.<li>The transition function $p$ describes how the environment evolves: given the current state and action, it specifies the probability of transitioning to the next state.<li>The reward function $r$ assigns a scalar feedback signal that tells the agent how desirable a state‚Äìaction pair is.<li>The discount factor $\gamma \in [0,1]$ controls how much the agent values future rewards relative to immediate ones.</ul><h2 id="agent-policy-model-and-planning"><span class="mr-2">Agent, Policy, Model, and Planning</span><a href="#agent-policy-model-and-planning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>An agent is the decision-making entity. It perceives the environment through sensors, acts through actuators, and has goals it wants to achieve. A policy is the agent‚Äôs behavior: it specifies what action to take in each state. Formally, a policy is a probability distribution over actions given states.</p>\[\pi(a \mid s) = \Pr(A_t = a \mid S_t = s), \forall t\]<p>A model describes how the environment works ‚Äî it predicts the next state and reward given the current state and action. Planning means using this model to look ahead into the future and choose actions that achieve a goal. A plan is simply a sequence of actions. In reinforcement learning, the agent often does not know the model in advance and must learn through interaction.</p><p>The goal of reinforcement learning is to learn a policy. Policies are typically assumed to be stationary, meaning the same policy is used at every time step. During learning, the agent updates its policy based on experience.</p><h2 id="markovian-states-why-history-can-be-thrown-away"><span class="mr-2">Markovian States (Why History Can Be Thrown Away)</span><a href="#markovian-states-why-history-can-be-thrown-away" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A state is called Markovian if it contains all the information needed to predict the future. This is known as the Markov property: given the current state and action, the future is independent of the past. Intuitively, this means the state is a sufficient summary of everything that has happened so far.</p>\[\Pr(R_{t+1}, S_{t+1} \mid S_0, A_0, \dots, S_t, A_t)=\Pr(R_{t+1}, S_{t+1} \mid S_t, A_t)\]<h2 id="rewards-and-returns"><span class="mr-2">Rewards and Returns</span><a href="#rewards-and-returns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Rewards are scalar signals provided by the environment that indicate progress toward a goal. Importantly, rewards define what the agent should accomplish, not how to do it. Almost all goal-directed behavior can be framed as maximizing the expected cumulative reward.</p><p>The reward function is often written as an expectation:</p>\[r(s, a) = \mathbb{E}[R_{t+1} \mid S_t = s, A_t = a]\]<p>In episodic tasks, interaction naturally breaks into episodes with a clear end, such as a game or navigating a maze. The return is the total reward accumulated until the terminal state:</p>\[G_t = R_{t+1} + R_{t+2} + \dots + R_T\]<p>Here, $T$ is the final time step of the episode. The agent‚Äôs objective is to maximize this return.</p><p>In continuing tasks, there is no natural episode boundary (e.g., robot control or stock trading). In this case, we use discounted returns to ensure the total reward remains finite and to prioritize near-term outcomes:</p>\[G_t = R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \dots = \sum_{k=0}^\infty \gamma^k R_{t+k+1}\]<p>The discount factor $\gamma$ determines how farsighted the agent is.</p><h1 id="value-based-vs-policy-based-reinforcement-learning">Value-Based vs Policy-Based Reinforcement Learning</h1><p>Value-based methods focus on learning a value function: a function that tells us how good a state or state-action pair is in terms of expected future reward. Once this value function is learned, the policy is not learned explicitly; instead, it is implicit, typically derived by choosing the action with the highest value (for example, using $\epsilon-$greedy exploration). Algorithms like Q-learning fall into this category.</p><p>Policy-based methods flip this idea around. Instead of learning values and deriving actions from them, the agent directly learns the policy itself, which is a mapping from states to actions or action distributions. There is no requirement to maintain or estimate a value function. The policy parameters are adjusted so that actions sampled from the policy lead to higher long-term reward. This makes policy-based methods especially natural for continuous action spaces, where choosing an action by ‚Äúargmax over values‚Äù is awkward or ill-defined.</p><p>Actor-Critic methods sit exactly at the intersection of these two ideas. They learn both a policy (the actor) and a value function (the critic). The critic evaluates how good the actor‚Äôs actions are, and this feedback is used to update the policy more efficiently and with lower variance.</p><h1 id="policy-based-rl">Policy-Based RL</h1><p>Policy-based reinforcement learning can be cleanly framed as a direct optimization problem. We define an objective function $U(\theta)$, which measures how good a policy parameterized by $\theta$ is. This is typically the expected cumulative reward when following that policy.</p><p>Learning then proceeds by iteratively improving the policy parameters. At each iteration, we first roll out the current policy in the environment to collect trajectories (sequences of states and actions generated by following the policy). Using these trajectories, we estimate how changing the policy parameters would affect the objective. Finally, we update the parameters in the direction that increases the objective. Intuitively, this is just like standard gradient ascent.</p>\[\theta_{\text{new}} = \theta_{\text{old}} + \alpha \nabla_\theta U(\theta)\]<p><strong>Why are they useful?</strong></p><p>One major advantage of policy-based methods is that they handle high-dimensional and continuous action spaces naturally. Instead of evaluating many possible actions and selecting the best one, the policy directly outputs an action (or a distribution over actions). This is especially important in robotics, where actions are often continuous (e.g., torques, velocities, steering angles).</p><p>Another key benefit is the ability to learn stochastic policies. Rather than committing to a single action in each state, the policy can represent uncertainty or intentional randomness, which is often crucial for exploration or for modeling multimodal behaviors.</p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image.png" alt="image.png" data-proofer-ignore></p><h2 id="reinforce-or-monte-carlo-policy-gradient"><span class="mr-2">REINFORCE (or Monte Carlo Policy Gradient)</span><a href="#reinforce-or-monte-carlo-policy-gradient" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In policy-based reinforcement learning, the agent does not try to estimate values first and then derive a policy. Instead, it directly optimizes the policy itself. To do this, we need to define a clear objective that tells us how good a policy is.</p><p>A trajectory $\tau$ is one full rollout of the agent interacting with the environment. It is simply a sequence of states and actions:</p>\[\tau = (s_0, a_0, s_1, a_1, \dots, s_H, a_H)\]<p>where $H$ is the horizon (episode length). Intuitively, a trajectory is ‚Äúone attempt‚Äù by the agent to solve the task from start to finish.</p><p>Since the environment is stochastic (and the policy may be stochastic too), the agent does not experience the same trajectory every time. Instead, trajectories are sampled from a probability distribution induced by the policy. Therefore, a reasonable objective is to maximize the expected trajectory reward:</p><aside> üí° $$ U(\theta) = \mathbb{E}_{\tau \sim P(\tau; \theta)}[R(\tau)] $$</aside><p><em><strong>Intuition:</strong> ‚ÄúOn average, how much reward does my policy get when I deploy it in the environment?‚Äù</em></p><p>The expectation can also be written explicitly as a sum over all possible trajectories:</p>\[U(\theta) = \sum_{\tau} P(\tau; \theta)\, R(\tau)\]<p><strong>Probability of a Trajectory:</strong></p><p>A trajectory is generated by two components:</p><ol><li>Environment dynamics: how states evolve<li>Policy: how actions are chosen</ol><p>The probability of a trajectory factorizes as:</p><aside> üí° $$ P(\tau; \theta) = \prod_{t=0}^{H} P(s_{t+1} \mid s_t, a_t)\, \pi_\theta(a_t \mid s_t) $$</aside><ul><li>The dynamics term $P(s_{t+1} \mid s_t,a_t)$ is fixed and unknown<li>The policy term $\pi_{\theta}(a_t \mid s_t)$ is what we control and parameterize</ul><h3 id="derivation"><span class="mr-2">Derivation</span><a href="#derivation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Our goal is not to compute the objective itself, but to compute its gradient with respect to the policy parameters:</p>\[\nabla_\theta U(\theta)= \nabla_\theta \mathbb{E}_{\tau \sim P(\tau; \theta)}[R(\tau)]\] \[\nabla_\theta U(\theta)= \sum_{\tau} \nabla_\theta P(\tau; \theta)\, R(\tau)\]<p>Now apply the log-derivative trick:</p>\[\nabla_\theta P(\tau; \theta)= P(\tau; \theta)\, \nabla_\theta \log P(\tau; \theta)\]<p>Substitute:</p>\[\nabla_\theta U(\theta)= \sum_{\tau} P(\tau; \theta)\, \nabla_\theta \log P(\tau; \theta)\, R(\tau)\]<p>This can be written as an expectation:</p>\[\nabla_\theta U(\theta)= \mathbb{E}_{\tau \sim P(\tau; \theta)}\left[ \nabla_\theta \log P(\tau; \theta)\, R(\tau) \right]\]<p>Recall the trajectory probability:</p>\[\log P(\tau; \theta)= \sum_{t=0}^{H} \log P(s_{t+1} \mid s_t, a_t)+ \sum_{t=0}^{H} \log \pi_\theta(a_t \mid s_t)\]<p>The environment dynamics do not depend on $\theta$, so their gradient is zero. This leaves:</p>\[\nabla_\theta \log P(\tau; \theta)= \sum_{t=0}^{H} \nabla_\theta \log \pi_\theta(a_t \mid s_t)\]<p>Substitute back into the gradient:</p><aside> üí° $$ \nabla_\theta U(\theta)= \mathbb{E}_{\tau}\left[\sum_{t=0}^{H}\nabla_\theta \log \pi_\theta(a_t \mid s_t)\, R(\tau)\right] $$</aside><p>Using Monte-Carlo sampling with $N$ trajectories:</p><aside> üí° $$ \nabla_\theta U(\theta)\approx\frac{1}{N}\sum_{i=1}^{N}\sum_{t=0}^{H}\nabla_\theta \log \pi_\theta(a_t^{(i)}\mid s_t^{(i)})\,R(\tau^{(i)}) $$</aside><p><strong>Intuition:</strong></p><p>Each term $\nabla_\theta \log \pi_\theta(a_t^{(i)}\mid s_t^{(i)})$ asks: <em>‚ÄúHow should I change the policy parameters to make this action more likely in this state?‚Äù</em></p><p>That change is scaled by the total reward $R(\tau)$:</p><ul><li>If the trajectory was good $\rightarrow$ reinforce the actions<li>If the trajectory was bad $\rightarrow$ suppress the actions</ul><p>So learning boils down to: <em>Increase the probability of actions that led to good outcomes, decrease the probability of actions that led to bad ones.</em></p><p>Assigning the full trajectory return to every action is wasteful. An action at time $t$ cannot affect rewards that happened before it. So we define the return from time $t$ onward:</p>\[G_t = \sum_{k=t}^{H} R(s_k, a_k)\]<p>Replace $R(\tau)$ with $G_t$:</p><aside> üí° $$ \nabla_\theta U(\theta)\approx\frac{1}{N}\sum_{i=1}^{N}\sum_{t=0}^{H}\nabla_\theta \log \pi_\theta(a_t^{(i)}\mid s_t^{(i)})\,G_t^{(i)} $$</aside><h3 id="gaussian-policy"><span class="mr-2">Gaussian Policy</span><a href="#gaussian-policy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Assume a continuous action space. The policy outputs the parameters of a Gaussian:</p>\[\pi_\theta(a \mid s) = \mathcal{N}\big(a \mid \mu_\theta(s), \sigma^2\big)\]<p>To keep things simple:</p><ul><li>Mean $\mu_\theta(s)$ depends on $\theta$<li>Variance $\sigma^2$ is fixed</ul><p>So at state $s_t$:</p><ol><li>The network outputs $\mu_\theta(s_t)$<li><p>The action is sampled:</p>\[a_t \sim \mathcal{N}(\mu_\theta(s_t), \sigma^2)\]</ol><p><strong>For a 1D Gaussian:</strong></p>\[\log \pi_\theta(a_t \mid s_t)= -\frac{1}{2\sigma^2}(a_t - \mu_\theta(s_t))^2 + C\]<p>We ignore constants because they vanish under gradients.</p>\[\nabla_\theta \log \pi_\theta(a_t \mid s_t)= \frac{(a_t - \mu_\theta(s_t))}{\sigma^2}\nabla_\theta \mu_\theta(s_t)\]<p><strong>For a 2D Gaussian:</strong></p><p>The policy outputs a mean vector:</p>\[\mu_\theta(s)=\begin{bmatrix}\mu_1(s) \\\mu_2(s)\end{bmatrix}\]<p>We assume a Gaussian policy with fixed covariance:</p>\[\pi_\theta(a \mid s)=\mathcal{N}\big(a \mid \mu_\theta(s), \Sigma\big)\] \[a \sim \mathcal{N}(\mu_\theta(s), \Sigma)\] \[\log \pi_\theta(a \mid s)=-\frac{1}{2}(a - \mu_\theta(s))^\top\Sigma^{-1}(a - \mu_\theta(s))+ C\] \[\nabla_\theta \log \pi_\theta(a \mid s)=\Sigma^{-1}(a - \mu_\theta(s))\;\nabla_\theta \mu_\theta(s)\]<p>This is the multi-dimensional generalization of the 1D case.</p><p><strong>Geometric Intuition:</strong></p><p>The vector $(a - \mu_\theta(s))$ points from the mean to the sampled action.</p><p>Then:</p><ul><li>$\Sigma^{-1}$ scales that vector<li>Directions with low variance get amplified<li>Directions with high variance get damped</ul><p>So the gradient says: <em>‚ÄúMove the mean toward the sampled action, but trust directions where the policy is more confident.‚Äù</em></p><p><strong>REINFORCE Update in 2D:</strong></p>\[\Delta \theta\propto\Sigma^{-1}(a_t - \mu_\theta(s_t))\nabla_\theta \mu_\theta(s_t)\; G_t\]<p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%201.png" alt="image.png" data-proofer-ignore></p><h3 id="softmax-policy"><span class="mr-2">Softmax Policy</span><a href="#softmax-policy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Now assume the action space is discrete. Instead of outputting a mean and variance, the policy outputs a score (logit) for each action. Let this score function be $h_\theta(s,a)$.</p><p>The policy converts scores into probabilities using softmax:</p>\[\pi_\theta(a \mid s)=\frac{\exp(h_\theta(s, a))}{\sum_{b} \exp(h_\theta(s, b))}\]<p>Key idea:</p><ul><li>Higher score $\rightarrow$ higher probability<li>Scores are unconstrained real numbers<li>Softmax turns them into a valid probability distribution</ul>\[\log \pi_\theta(a \mid s)=h_\theta(s, a)-\log \sum_{b} \exp(h_\theta(s, b))\] \[\nabla_\theta \log \pi_\theta(a \mid s) = \nabla_\theta h_\theta(s,a) - \nabla_\theta \log \sum_{b} \exp(h_\theta(s,b))\] \[\nabla_\theta \log \sum_{b} \exp(h_\theta(s,b))=\frac{1}{\sum_{b} \exp(h_\theta(s,b))}\nabla_\theta \sum_{b} \exp(h_\theta(s,b))\] \[\nabla_\theta \sum_{b} \exp(h_\theta(s,b))=\sum_{b} \nabla_\theta \exp(h_\theta(s,b)) =\sum_{b} \exp(h_\theta(s,b)) \nabla_\theta h_\theta(s,b)\] \[\nabla_\theta \log \sum_{b} \exp(h_\theta(s,b))=\frac{\sum_{b} \exp(h_\theta(s,b)) \nabla_\theta h_\theta(s,b)}{\sum_{b} \exp(h_\theta(s,b))} \\ = \sum_{b} \frac{\exp(h_\theta(s,b))}{\sum_{b'} \exp(h_\theta(s,b'))} \nabla_\theta h_\theta(s,b)\]<p>But this fraction is exactly the softmax probability:</p>\[\pi_\theta(b \mid s)=\frac{\exp(h_\theta(s,b))}{\sum_{b'} \exp(h_\theta(s,b'))}\]<p>So the entire term becomes:</p>\[\nabla_\theta \log \sum_{b} \exp(h_\theta(s,b))=\sum_{b} \pi_\theta(b \mid s)\, \nabla_\theta h_\theta(s,b)\] \[\nabla_\theta \log \pi_\theta(a \mid s)=\nabla_\theta h_\theta(s,a)-\sum_{b} \pi_\theta(b \mid s)\, \nabla_\theta h_\theta(s,b)\]<p><strong>Intuition:</strong></p><p>The softmax policy gradient has two terms because learning in discrete action spaces is about redistributing probability mass, not independently increasing action scores. Increasing the score of a chosen action must be balanced by decreasing the scores of other actions to preserve normalization. The gradient therefore increases the score of the selected action while subtracting the probability-weighted average score gradient of all actions, ensuring that probability mass shifts toward better actions in a competitive manner.</p><p><strong>Algorithm:</strong></p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%202.png" alt="image.png" data-proofer-ignore></p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%203.png" alt="image.png" data-proofer-ignore></p><h3 id="limitations"><span class="mr-2">Limitations</span><a href="#limitations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Mathematically, the REINFORCE update is:</p>\[\nabla_\theta U(\theta)\approx\sum_{t}\nabla_\theta \log \pi_\theta(a_t \mid s_t)\, G_t\]<p>The return $G_t$ is a very blunt learning signal. It mixes together two fundamentally different effects:</p><ol><li>State quality: some states are inherently good or bad<li>Action quality: some actions are better than others within the same state</ol><p>REINFORCE cannot distinguish between these. If the agent is in a bad state, all actions receive low returns and are suppressed, even if one of them was the best possible choice. Conversely, in a good state, all actions are reinforced, even if some were poor.</p><p>This is why REINFORCE updates are extremely noisy: it is trying to solve a fine-grained credit assignment problem using a coarse, trajectory-level signal.</p><h2 id="actor-critic"><span class="mr-2">Actor-Critic</span><a href="#actor-critic" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Building upon the limitations of the REINFORCE algorithm, we infer a key conceptual insight: <em>we should not judge an action by how good the episode was, but by how good the action was relative to the state in which it was taken.</em></p><h3 id="baseline"><span class="mr-2">Baseline</span><a href="#baseline" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>REINFORCE updates the policy using returns:</p>\[\nabla_\theta U(\theta)\approx\sum_t\nabla_\theta \log \pi_\theta(a_t \mid s_t)\, G_t\]<p>This estimator is unbiased, but extremely high variance. This is because the return $G_t$ contains a lot of irrelevant information. It depends on:</p><ul><li>the quality of the state<li>randomness in the environment<li>future actions that had nothing to do with the current action</ul><p>So the policy gradient ends up reacting strongly to things the action did not cause. Intuitively, the algorithm is asking <em>‚ÄúWas this episode good?‚Äù</em>, when it should be asking <em>‚ÄúWas this action good for this state?‚Äù</em></p><p>If the agent is in a bad state, all actions receive low returns and are suppressed, even if one of them was the best possible choice. Conversely, in a good state, all actions are reinforced, even if some were poor. This is why REINFORCE updates are extremely noisy: it is trying to solve a fine-grained credit assignment problem using a coarse, trajectory-level signal.</p><p>The baseline exists to fix exactly this mismatch.</p><p>A baseline is simply a reference value that we subtract from the return before using it as a learning signal. So instead of using $G_t$, we use $(G_t-b)$.</p><p><strong>Baseline choices:</strong></p><ul><li><p>Constant baseline (single scalar): $b = \mathbb{E}[R(\tau)]$</p>\[\hat{g}=\frac{1}{N}\sum_{i=1}^{N}\sum_{t=1}^{T}\nabla_\theta \log \pi_\theta(a_t^{(i)} \mid s_t^{(i)})\left(G_t^{(i)} - b\right)\]<p>This baseline removes global reward bias. If all trajectories tend to have large positive (or negative) returns, the policy gradient would otherwise push parameters strongly even when actions are not particularly informative. The constant baseline recenters the learning signal so that updates reflect relative success across trajectories.</p><li><p>Time-dependent Baseline (a vector length $T$): $b_t = \frac{1}{N} \sum_{i=1}^{N} G_t^{(i)}$</p>\[\hat{g}=\frac{1}{N}\sum_{i=1}^{N}\sum_{t=1}^{T}\nabla_\theta \log \pi_\theta(a_t^{(i)} \mid s_t^{(i)})\left(G_t^{(i)} - b_t\right)\]<p>Many tasks have systematic reward structure over time. Early actions tend to have larger remaining returns than late actions simply because more rewards are still ahead. A time-dependent baseline removes this predictable temporal effect, allowing the gradient to focus on deviations from the average behavior at that timestep.</p><li><p>State-dependent Baseline (a function):</p>\[b(s)=\mathbb{E}[r_t + r_{t+1} + \dots + r_{T-1} \mid s_t = s]=V^\pi(s)\] \[\hat{g}=\frac{1}{N}\sum_{i=1}^{N}\sum_{t=0}^{T}\nabla_\theta \log \pi_\theta(a_t^{(i)} \mid s_t^{(i)})\left(G_t^{(i)} - V^\pi(s_t^{(i)})\right)\]<p>Subtracting this baseline removes the effect of how easy or difficult the state is, leaving only information about the quality of the chosen action. The learning signal now answers a precise question: <em>was this action better or worse than what I normally do in this state?</em> This produces stable, low-variance updates and leads directly to the advantage function.</p></ul><p>We want to encourage an action not when it has high return, but when it has higher return than the other actions from that state, that is, when it has an advantage over the other actions. It may well be that a state is bad and all actions have low returns in that state, but we do not care. The actions that have higher returns than the rest are the ones we want to reinforce. Therefore, we need to calibrate the goodness of actions using state-dependent baselines.</p><p><strong>Why subtracting a baseline helps?</strong></p><p>Consider two states:</p><ul><li>A good state where all actions give high reward<li>A bad state where all actions give low reward</ul><p>Without a baseline, good states reinforce everything, and bad states suppress everything. This is useless for learning which action is better.</p><p>With a baseline, only actions that outperform the state average are reinforced, and only actions that underperform are suppressed.</p><p>So the baseline removes the effect of state quality from the learning signal.</p><p><strong>Does subtracting a baseline change the gradient?</strong></p><p>The true policy gradient is:</p>\[\nabla_\theta U(\theta)=\mathbb{E}_{\tau \sim \pi_\theta}\left[\sum_t\nabla_\theta \log \pi_\theta(a_t \mid s_t)\, G_t\right]\]<p>Now suppose we subtract a baseline $b(s_t)$:</p>\[\mathbb{E}\left[\sum_t\nabla_\theta \log \pi_\theta(a_t \mid s_t)\,(G_t - b(s_t))\right]\] \[=\mathbb{E}\left[\sum_t\nabla_\theta \log \pi_\theta(a_t \mid s_t)\, G_t\right]-\mathbb{E}\left[\sum_t\nabla_\theta \log \pi_\theta(a_t \mid s_t)\, b(s_t)\right]\]<p>Focus on the second term:</p>\[\mathbb{E}\left[\nabla_\theta \log \pi_\theta(a_t \mid s_t)\, b(s_t)\right]\]<p>Since $b(s_t)$ does not depend on the action, we can pull it out of the inner expectation:</p>\[=\mathbb{E}_{s_t}\left[b(s_t)\;\mathbb{E}_{a_t \sim \pi_\theta(\cdot \mid s_t)}\left[\nabla_\theta \log \pi_\theta(a_t \mid s_t)\right]\right]\] \[\mathbb{E}_{a \sim \pi}[\nabla_\theta \log \pi(a)]=\sum_a \pi(a) \nabla_\theta \log \pi(a)=\sum_a \nabla_\theta \pi(a)=\nabla_\theta \sum_a \pi(a)=\nabla_\theta 1=0\]<p>So the entire baseline term vanishes in expectation. This shows that subtracting any baseline that depends only on the state:</p><ul><li>does not change the expected gradient<li>does reduce variance</ul><p>So the estimator remains unbiased, but becomes far more stable.</p><h3 id="how-do-we-learn-the-state-dependent-baseline-vpis"><span class="mr-2">How do we learn the state-dependent baseline $V^\pi(s)$?</span><a href="#how-do-we-learn-the-state-dependent-baseline-vpis" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The value function is defined as the expected future return starting from a state and following the current policy:</p>\[V^\pi(s)=\mathbb{E}\left[\sum_{k=0}^{\infty} \gamma^k r_{t+k}\;\middle \mid \;s_t = s\right]\]<p>In real environments, the true value function is unknown. We only observe sampled trajectories, not expectations. Therefore, the value function must be learned from experience, using the same data generated by the policy.</p><p>There are two fundamental strategies for doing this:</p><ol><li>Monte Carlo (MC) estimation<li>Temporal-Difference (TD) estimation</ol><p>Both aim to approximate the same quantity $V^\pi(s)$, but they differ in <em>how much of the future they wait to observe</em> before making an update.</p><p><strong>Monte Carlo Value Estimation:</strong></p><p>Monte Carlo methods estimate the value of a state by waiting until the episode finishes, then using the actual observed return as the training target.</p><p><em><strong>Intuition:</strong> ‚ÄúDon‚Äôt guess the future. Wait and see what really happens.‚Äù</em></p><p>For a state visited at time $t$, the Monte Carlo return is:</p>\[G_t=r_t + \gamma r_{t+1} + \gamma^2 r_{t+2} + \dots + \gamma^{T-t} r_T\]<p>This return is treated as a sample of the true value:</p>\[V^\pi(s_t) \approx G_t\]<p>If the value function is parameterized by $\phi$, it can be trained via regression:</p>\[\mathcal{L}_{MC}(\phi)=\left( V_\phi(s_t) - G_t \right)^2\]<p>Monte Carlo estimation is:</p><ul><li>Unbiased, because it uses the true outcome<li>High variance, because returns depend on everything that happens later<li>Delayed, because updates occur only after the episode ends</ul><p>This makes MC estimation conceptually clean but often impractical for long-horizon or sparse-reward problems.</p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%204.png" alt="image.png" data-proofer-ignore></p><p><strong>Temporal-Difference (TD) Value Estimation:</strong></p><p>Temporal-Difference methods update the value function before the episode ends by bootstrapping from the current value estimate of the next state.</p><p><em><strong>Intuition:</strong> ‚ÄúUse what I already believe about the future, and correct myself if I‚Äôm wrong.‚Äù</em></p><p>Instead of waiting for the full return, TD uses a one-step lookahead:</p>\[r_t + \gamma V_\phi(s_{t+1})\]<p>The TD error is defined as:</p>\[\delta_t=r_t + \gamma V_\phi(s_{t+1}) - V_\phi(s_t)\]<p>This error measures how surprised the value function is by new experience. The value function is trained to minimize this prediction error:</p>\[\mathcal{L}_{TD}(\phi)=\delta_t^2\]<p>Temporal-Difference estimation is:</p><ul><li>Lower variance, because it uses shorter-horizon targets<li>Biased, because it relies on imperfect value estimates<li>Online, allowing updates at every timestep</ul><p>In practice, the reduced variance and faster learning usually outweigh the bias.</p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%205.png" alt="image.png" data-proofer-ignore></p><p>Once a value function is available, it can be used as a baseline to compute advantages.</p><p>Monte Carlo Advantage:</p>\[A_t^{MC}=G_t - V_\phi(s_t)\]<p>TD Advantage:</p>\[A_t^{TD}=r_t + \gamma V_\phi(s_{t+1}) - V_\phi(s_t)\]<p>A positive advantage $A^{\pi}(s,a) &gt; 0$ means that action $a$ in state $s$ leads to returns higher than the expected value of that state ‚Äî it‚Äôs better than what the policy typically does from that state. A negative advantage means it‚Äôs worse. So computing advantages is essentially identifying which actions should be made more likely (positive advantage) and which should be made less likely (negative advantage).</p><h3 id="the-core-actor-critic-framework"><span class="mr-2">The Core Actor-Critic Framework</span><a href="#the-core-actor-critic-framework" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Actor-Critic methods maintain two separate components working in tandem: an actor (the policy network) that decides which actions to take, and a critic (the value function network) that evaluates how good those actions are. Think of it like a performer and a coach: the actor performs actions in the environment, while the critic watches and provides feedback on performance. The actor uses this feedback to improve its policy parameters through gradient ascent, while the critic learns to better evaluate states by observing the actual rewards received. In the basic Actor-Critic algorithm, after collecting trajectories by running the current policy, you update the critic to fit a value function $V_{\phi}^{\pi}(s)$ using either Monte Carlo or Temporal Difference estimation. Then, for the policy gradient update, you compute:</p>\[\nabla_\theta U(\theta) \approx \hat{g} = \frac{1}{N} \sum_{i=1}^{N} \sum_{t=1}^{T} \nabla_\theta \log \pi_\theta(a_t^{(i)} \mid s_t^{(i)}) A^\pi(s_t^{i}, a_t^{i})\]<p>where the advantage $A^\pi(s_t^i, a_t^i) = G_t^{(i)} - V_{\phi}^{\pi}(s_t^i)$ and $G_t^{(i)}$ is the sample return (the sum of all rewards from time $t$ onward in that trajectory).</p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%206.png" alt="image.png" data-proofer-ignore></p><h3 id="advantage-actor-critic-a2c"><span class="mr-2">Advantage Actor-Critic (A2C)</span><a href="#advantage-actor-critic-a2c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The key innovation in A2C is in how it computes the advantage. Instead of using the full Monte Carlo return $G_t$ and subtracting the value function baseline, it uses a bootstrapped estimate. The advantage becomes:</p>\[A^\pi(s_t^i, a_t^i) = R(s_t^i, a_t^i) + \gamma V_{\phi}^{\pi}(s_{t+1}^i) - V_{\phi}^{\pi}(s_t^i)\]<p>This is essentially a one-step TD error.</p><p>Instead of waiting to collect the entire trajectory‚Äôs return, you‚Äôre using the immediate reward $R(s_t, a_t)$ plus the estimated value of the next state $\gamma V(s_{t+1})$ and comparing that to your current state‚Äôs value $V(s_t)$.</p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%207.png" alt="image.png" data-proofer-ignore></p><p>In general, it is useful to remember the following about advantage function:</p>\[A^\pi(s,a) = Q^\pi(s,a) - V^\pi(s)\] \[\mathbb{E}_{a \sim \pi}[A^\pi(s,a)] = 0\]<h3 id="why-this-difference-matters-a2c-vs-ac"><span class="mr-2">Why This Difference Matters: A2C vs AC</span><a href="#why-this-difference-matters-a2c-vs-ac" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The distinction might seem subtle, but it has profound implications for learning efficiency and variance. To understand why, imagine you‚Äôre learning to play a game where each episode lasts 1000 steps. In basic Actor-Critic using full returns, the advantage at time step t=5 depends on everything that happens for the next 995 steps. This creates enormous variance. Maybe you made a great move at step 5, but 800 steps later something random happened that ruined the episode. Your advantage estimate would unfairly penalize that early good decision. Advantage Actor-Critic solves this by using the TD error, which essentially asks: <em>‚ÄúGiven what I expected the value of my current state to be, did taking this action and moving to the next state exceed or fall short of expectations?‚Äù</em> This is a much more localized signal. You‚Äôre only looking one step ahead (or k steps if using k-step returns), and you‚Äôre bootstrapping the rest using your learned value function. This dramatically reduces variance at the cost of introducing some bias (since your value function estimate might be wrong). Think of it like getting feedback on your work. Monte Carlo returns (used in basic Actor-Critic) are like waiting until a project is completely finished before getting any evaluation ‚Äî you get an unbiased assessment, but it‚Äôs very noisy because many things could have gone wrong along the way. The TD approach (used in Advantage Actor-Critic) is like getting incremental feedback after each task: ‚ÄúYou did better/worse than I expected given where you started.‚Äù It‚Äôs slightly biased by your coach‚Äôs potentially imperfect expectations, but it‚Äôs much more consistent and immediate.</p><p>From an implementation standpoint, both methods follow similar algorithmic structure ‚Äî they both initialize policy and critic parameters, sample trajectories, fit the value function, compute advantages, and update the policy. The crucial line that differs is step 3, where advantages are computed.</p><h3 id="actor-critic-as-policy-iteration"><span class="mr-2">Actor-Critic as Policy Iteration</span><a href="#actor-critic-as-policy-iteration" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Policy iteration alternates between two phases in a loop: policy evaluation and policy improvement. During policy evaluation, you fix your current policy $\pi$ and compute its value function, essentially answering ‚Äúhow good is each state under my current policy?‚Äù Then, during policy improvement, you create a new policy that‚Äôs greedy with respect to these values, meaning you switch to actions that have higher Q-values than the average. This two-step dance is guaranteed to converge to the optimal policy under certain conditions.</p><p>Actor-critic methods implement the same fundamental structure as classical policy iteration, but in a continuous, gradient-based way rather than through discrete policy updates.</p><p>The gradient update $\theta \leftarrow \theta + \alpha \nabla_\theta U(\theta)$ increases the probability of actions with positive advantages and decreases the probability of actions with negative advantages. This single update step is the policy improvement. You don‚Äôt need to do anything separately. It‚Äôs a soft, gradual version of the greedy policy switch in classical policy iteration.</p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%208.png" alt="image.png" data-proofer-ignore></p><p>Actor-critic is an on-policy method: you‚Äôre evaluating your current policy $\pi_\theta$, computing how good actions are under that specific policy, and then improving that same policy. The data you collected is intrinsically tied to the policy that generated it, just like in policy iteration where $V^{\pi}$ and $Q^{\pi}$ are defined relative to a specific policy $\pi$.</p><h2 id="asynchronous-deep-rl-for-on-policy-learning"><span class="mr-2">Asynchronous Deep RL for On-Policy Learning</span><a href="#asynchronous-deep-rl-for-on-policy-learning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="the-core-problem"><span class="mr-2">The Core Problem</span><a href="#the-core-problem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>When training neural networks for reinforcement learning, gradient updates need to be decorrelated for stable learning. However, this creates a fundamental problem for on-policy methods like REINFORCE and actor-critic. When you collect experience sequentially by running a single agent through an environment, consecutive states and actions are highly correlated ‚Äî each state naturally follows from the previous one. If you compute gradient updates from these sequential, correlated experiences, your value function approximator tends to oscillate and become unstable.</p><h3 id="the-asynchronous-solution-parallel-experience-collection"><span class="mr-2">The Asynchronous Solution: Parallel Experience Collection</span><a href="#the-asynchronous-solution-parallel-experience-collection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The key insight of asynchronous deep RL is to parallelize the collection of experience to break these correlations and stabilize training. Instead of running a single agent, you run multiple independent threads of experience simultaneously ‚Äî one agent per thread. Each agent explores a different part of the environment at the same time, contributing experience tuples (state, action, reward, next state) from diverse regions of the state space. Because these parallel agents are in different states and taking different actions, their experiences are much less correlated than sequential data from a single agent would be.</p><p>This approach is particularly crucial for on-policy algorithms like actor-critic because they can‚Äôt simply use a replay buffer of old experiences (that would violate the on-policy constraint where data must come from the current policy). Instead, asynchronous parallel collection provides the decorrelation benefits you‚Äôd get from experience replay, while still maintaining the on-policy property ‚Äî all workers are running approximately the same current policy. The diversity comes from spatial exploration across parallel environments rather than temporal diversity from replaying old experiences. The result is much more stable and efficient training. Neural networks converge faster, value function estimates are more accurate, and policies learn more robustly without the wild oscillations that plague sequential single-agent on-policy learning.</p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%209.png" alt="image.png" data-proofer-ignore></p><p><strong>How It Works in Practice</strong></p><p>The algorithm runs multiple worker agents in parallel, each with their own copy of the environment. These workers collect trajectories independently and asynchronously. Each worker periodically computes gradients based on its local experience and sends these gradients to a central parameter server (or directly updates shared parameters with appropriate synchronization). The key architectural choice is whether to do this fully asynchronously (A3C - Asynchronous Advantage Actor-Critic) where workers update independently whenever they‚Äôre ready, or synchronously (A2C) where all workers wait for each other and their gradients are averaged before updating the central network.</p><h3 id="asynchronous-advantage-actor-critic-a3c"><span class="mr-2">Asynchronous Advantage Actor-Critic (A3C)</span><a href="#asynchronous-advantage-actor-critic-a3c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%2010.png" alt="image.png" data-proofer-ignore></p><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%2011.png" alt="image.png" data-proofer-ignore></p><h1 id="evolutionary-methods-for-policy-search">Evolutionary Methods for Policy Search</h1><h2 id="black-box-policy-optimization"><span class="mr-2">Black-Box Policy Optimization</span><a href="#black-box-policy-optimization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Black-box policy optimization represents a fundamentally different approach to reinforcement learning compared to the gradient-based methods you‚Äôve studied. Instead of exploiting the structure of the problem (how states connect to each other, how rewards decompose over timesteps), black-box methods treat the entire RL problem as an opaque function to be optimized.</p><p>You‚Äôre solving:</p>\[\max_{\theta} U(\theta) = \mathbb{E}_{\tau \sim \pi_\theta} [R(\tau) \mid \pi_\theta, \mu_0(s_0)]\]<p>You only interact with this objective function by querying it. You try some parameters $\theta$, run the policy, get back a scalar reward $R(\tau)$, and that‚Äôs all you know. You don‚Äôt compute gradients, you don‚Äôt learn value functions, you don‚Äôt exploit the Markov structure of the MDP.</p><p><strong>Algorithm:</strong></p><ol><li>Initialize policy parameters randomly<li>Perturb the parameters (create variations, mutations, offspring)<li>Evaluate each perturbed policy by running it in the environment<li>Select which perturbations led to better performance<li>Update your parameters toward the better-performing variations<li>Repeat</ol><h2 id="cross-entropy-method-cem"><span class="mr-2">Cross-Entropy Method (CEM)</span><a href="#cross-entropy-method-cem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Principle: keep trying random variations of your policy, remember which ones worked best, and adjust your search distribution to generate more samples like the good ones.</p><p>CEM models your policy parameters as random variables drawn from a probability distribution. Specifically, it uses a multivariate Gaussian with a diagonal covariance matrix:</p>\[\theta \sim \mathcal{N}(\mu, \sigma^2 I)\]<p><strong>Algorithm:</strong></p><ol><li>Initialization: Start with $Œº = 0$ and $œÉ¬≤ = 100I$. This means you‚Äôre initially searching with a lot of noise, exploring broadly.<li><p>Sampling: Generate n random parameter vectors by sampling from your current Gaussian. Think of this as creating $n$ ‚Äúoffspring‚Äù or ‚Äúmutants‚Äù of your current best guess:</p>\[{\theta_i}_{i=1}^n \sim \mathcal{N}(\mu, \sigma^2 I)\]<li>Evaluation: For each $\theta_i$, run the policy in the environment for $L$ episodes and compute the average score. This is the fitness: how well did that particular parameter vector perform?<li>Selection: You don‚Äôt use all $n$ samples. Instead, you select only the top $[\rho n]$ performers (where $œÅ ‚â§ 1$, typically around 0.1 or 0.2). These are your winners, the parameter vectors that led to the best performance.<li><p>Update: Now you shift your search distribution toward these elites. The new mean becomes the average of the elite samples:</p>\[\mu(j) = \frac{1}{[\rho n]} \sum_{i=1}^{[\rho n]} \theta'_i(j)\]<p>And the new variance is computed from how spread out the elites are:</p>\[¬†\sigma^2(j) = \frac{1}{[\rho n]} \sum_{i=1}^{[\rho n]} [\theta'_i(j) - \mu(j)]^2 + \eta\]<p>$\eta$ is the added noise to prevent the variance from collapsing to zero, which would kill exploration.</p></ol><p><img data-src="/assets/images/Deep%20Reinforcement%20Learning/image%2012.png" alt="image.png" data-proofer-ignore></p><p>CEM struggles as dimensionality grows. With neural networks having thousands or millions of parameters, the diagonal Gaussian assumption becomes too restrictive, and the selection mechanism (only keeping top $\rho$ fraction) throws away most of your sampled information.</p><h2 id="covariance-matrix-adaptation-evolution-strategy-cma-es"><span class="mr-2">Covariance Matrix Adaptation Evolution Strategy (CMA-ES)</span><a href="#covariance-matrix-adaptation-evolution-strategy-cma-es" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>While CEM used a diagonal covariance matrix (assuming parameter independence), CMA-ES uses a full covariance matrix. This means it learns and exploits correlations between parameters, making it dramatically more powerful, though also more complex.</p><p>CEM sampled from:</p>\[¬†\theta \sim \mathcal{N}(\mu, \sigma^2 I)\]<p>CMA-ES generalizes this to:</p>\[\theta \sim \mathcal{N}(\mu, \Sigma)\]<p><strong>Visual Intuition:</strong></p><p>With diagonal covariance (CEM), your search distribution is always axis-aligned ‚Äî you can only scale search along the coordinate axes. But the optimal search direction might be diagonal.</p><p>CMA-ES adapts the ellipse to match the problem geometry. If the fitness landscape is like a valley running northeast-southwest, CMA-ES will stretch its sampling ellipse along that valley. This dramatically improves efficiency because you‚Äôre searching along the natural contours of the problem rather than fighting against them.</p><p><strong>Algorithm:</strong></p><ol><li>Sample: Draw $n$ parameter vectors from your current Gaussian $\mathcal{N}(\mu_i, C_i)$, where $C$ is the covariance matrix at iteration $i$.<li>Select Elites: Evaluate each sample‚Äôs fitness and keep the top performers, just like CEM.<li><p>Update Mean: Move your center $\mu$ toward the weighted average of the elite samples:</p>\[\mu_{t+1} = \mu_t + \alpha \sum_{i=1}^{n_{elit}} w_i(\theta_i^{elit,t} - \mu_t)\]<li><p>Update Covariance:</p>\[¬†\Sigma_{t+1} = \text{Cov}(\theta_1^{elit,t}, \theta_2^{elit,t}, \ldots) + \epsilon I\]<p>This tells you: ‚ÄúWhat directions in parameter space led to good performance?‚Äù The covariance matrix encodes these productive search directions. The $\epsilon I$ term (small noise on the diagonal) prevents the matrix from becoming singular.</p></ol><h2 id="natural-evolutionary-strategies-nes"><span class="mr-2">Natural Evolutionary Strategies (NES)</span><a href="#natural-evolutionary-strategies-nes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>CEM and CMA-ES had a clear selection mechanism: evaluate samples, keep the elites, throw away the rest. NES takes a different approach: every offspring contributes to the update, weighted by its fitness.</p><p>NES maintains a Gaussian distribution over policy parameters, but for computational tractability with neural networks, it uses a diagonal covariance with fixed variance:</p>\[\theta \sim P_\mu(\theta) = \mathcal{N}(\mu, \sigma^2 I_d)\]<p>Where:</p><ul><li>$\mu \in ‚Ñù^d$ is the mean (what we‚Äôre optimizing)<li>$œÉ¬≤I_d$ is a fixed diagonal covariance ($\sigma$ is a hyperparameter)<li>$d$ is the parameter dimension</ul><p>The goal is to maximize the expected fitness:</p>\[\max_\mu U(\mu) = \mathbb{E}_{\theta \sim P\mu(\theta)} [F(\theta)]\]<p>where $F(\theta)$ is the fitness (total return) when running policy $\pi \theta$.</p><h3 id="derivation-1"><span class="mr-2">Derivation</span><a href="#derivation-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>\[\nabla_\mu U(\mu) = \nabla_\mu \mathbb{E}_{\theta \sim P\mu(\theta)} [F(\theta)]\]<p>We can write the expectation as an integral:</p>\[\nabla_\mu U(\mu) = \nabla_\mu \int P_\mu(\theta) F(\theta) d\theta\] \[= \int \nabla_\mu P_\mu(\theta) F(\theta) d\theta\]<p>Log-likelihood trick:</p>\[\nabla_\mu U(\mu) = \int P_\mu(\theta) \frac{\nabla_\mu P_\mu(\theta)}{P_\mu(\theta)} F(\theta) d\theta\] \[= \int P_\mu(\theta) \nabla_\mu \log P_\mu(\theta) F(\theta) d\theta\] \[= \mathbb{E}_{\theta \sim P\mu(\theta)} [\nabla_\mu \log P_\mu(\theta) F(\theta)]\]<p>This is exactly the same trick used in policy gradients! Just like REINFORCE transforms policy gradients into an expectation, NES transforms parameter distribution gradients into an expectation.</p><p>Since we have an expectation, we can approximate it by sampling:</p>\[¬†\nabla_\mu U(\mu) \approx \frac{1}{N} \sum_{i=1}^N \nabla_\mu \log P_\mu(\theta^{(i)}) F(\theta^{(i)})\]<p>where each $\theta^i \sim P_\mu(\theta)$.</p><p>For our Gaussian with mean $\mu$ and fixed variance $\sigma^2I$:</p>\[¬†\log P_\mu(\theta) = -\frac{|\theta - \mu|^2}{2\sigma^2} + \text{const}\]<p>Taking the gradient with respect to $\mu$:</p>\[\nabla_\mu \log P_\mu(\theta) = \frac{\theta - \mu}{\sigma^2}\]<p>So the NES update becomes:</p>\[\mu_{t+1} = \mu_t + \frac{\alpha}{N\sigma} \sum_{i=1}^N F(\theta_i) \epsilon_i\]<p>where $\theta_i = \mu_t + \sigma \epsilon_i$ and $\epsilon_i \sim \mathcal{N}(0,I)$.</p><h1 id="value-based-rl">Value-Based RL</h1><h2 id="review-actor-critic-and-the-advantage-function"><span class="mr-2">Review: Actor-Critic and the Advantage Function</span><a href="#review-actor-critic-and-the-advantage-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>We saw previously that in actor-critic methods, we‚Äôre optimizing a policy gradient objective that looks like this:</p>\[\nabla_\theta U(\theta) = \mathbb{E}_{\tau \sim \pi_\theta(\tau)} \left[ \sum_{t=0}^{T} \nabla_\theta \log \pi_\theta(a_t \mid s_t) \cdot A^{\pi}(s_t, a_t) \right]\]<p>The advantage function plays a crucial role here, serving as our signal for which actions are better than average. The advantage is formally defined as:</p>\[A^{\pi}(s_t, a_t) = r(s_t, a_t) + \gamma V^{\pi}(s_{t+1}) - V^{\pi}(s_t)\]<p><strong>Intuition:</strong> The term $r(s_t, a_t) + \gamma V^\pi(s_{t+1})$ represents the Q-value of the state-action pair, essentially asking <em>‚Äúwhat‚Äôs the total expected return if I take action $a_t$ in state $s_t$ and then follow $\pi$ afterward?‚Äù</em> By subtracting the value function $V^\pi(s_t)$, which represents the average value of being in that state, we get a relative measure. The advantage tells us: <em>‚Äúhow much better is this specific action compared to what we‚Äôd typically expect in this state?‚Äù</em></p><p>We can also express the advantage function in terms of Q-values and values:</p>\[A^{\pi}(s_t, a_t) = Q^{\pi}(s_t, a_t) - V^{\pi}(s_t)\]<p>General policy-based RL workflow:</p><ol><li>We collect trajectories by rolling out our current policy in the environment<li>We estimate how good each action was by computing returns or advantages through policy evaluation<li>We improve the policy by adjusting it to favor actions with higher estimated advantages.</ol><h2 id="the-value-based-approach"><span class="mr-2">The Value-Based Approach</span><a href="#the-value-based-approach" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Now we arrive at a fundamental question that motivates value-based RL: if we had a perfect estimate of the advantage function, would we even need to maintain an explicit policy? The answer is no, and this insight drives the entire value-based methodology.</p><p>Think about it this way: in policy-based methods, we‚Äôre using the advantage estimates to nudge our policy parameters gradually in the direction of better actions. We collect data, estimate advantages using rollouts from our policy, compute gradients, and take small steps. But if we somehow had perfect knowledge of $A^\pi(s,a)$ for all state-action pairs, we could simply construct the optimal policy by taking the argmax:</p>\[\pi(s) \leftarrow \argmax_a A^\pi(s,a)\]<p>This leads to the value-based RL skeleton, which differs from policy-based methods primarily in steps 2 and 3:</p><ol><li>Collect data in the environment using the current policy $\pi$ (with some exploration noise to ensure we visit diverse states).<li>Estimate the advantage function $A^\pi(s,a)$ as perfectly as possible rather than just well enough to compute a policy gradient. This is where we invest most of our effort by building the most accurate model we can of which actions are truly better.<li>Update the policy via argmax by setting $\pi‚Äô(s) = \argmax_a A^\pi(s, a)$ for all states. Notice this is ‚Äúoff-policy‚Äù in the sense that we‚Äôre not computing gradients of the policy itself; we‚Äôre simply choosing the best action according to our learned advantage estimates.</ol><p>We don‚Äôt need to worry about policy parameterization, gradient estimation, or learning rates for the policy. If our advantage estimates are good, the policy update is trivial ‚Äî just pick the best action.</p><h2 id="value-iteration-and-q-learning"><span class="mr-2">Value Iteration and Q-Learning</span><a href="#value-iteration-and-q-learning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The theoretical algorithm that formalizes this idea is called dynamic programming or value iteration. The core of value iteration is the Bellman equation for the Q-function:</p>\[Q(s, a) = r(s, a) + \gamma \mathbb{E}_{s' \sim p(\cdot \mid s, a)} [V(s')]\]<p><em><strong>Intuition:</strong> ‚ÄúThe value of taking action $a$ in state $s$ equals the immediate reward plus the discounted expected value of wherever we end up next.‚Äù</em></p><p>The value iteration algorithm alternates between two updates:</p><ol><li><p>Update 1: Update Q-values using the Bellman equation:</p>\[Q(s, a) \leftarrow r(s, a) + \gamma \mathbb{E}_{s'} [V(s')]\]<li><p>Update 2: Update the value function by taking the max over actions:</p>\[V(s) \leftarrow \max_a Q(s, a)\]</ol><p>These updates are performed iteratively until convergence. In tabular settings (where we have finite state and action spaces), we can literally maintain a table with entries $Q(s, a)$ for every possible state-action pair, and this algorithm is guaranteed to converge to the optimal Q-function.</p><p>But here‚Äôs the practical challenge: how do we implement this when we have large or continuous state spaces? We need function approximation.</p><h3 id="fitted-q-iteration-neural-networks-for-value-functions"><span class="mr-2">Fitted Q-Iteration: Neural Networks for Value Functions</span><a href="#fitted-q-iteration-neural-networks-for-value-functions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>To scale value-based methods to complex domains, we use neural networks to approximate the Q-function. This leads to fitted Q-iteration, where instead of maintaining a table, we train a neural network $Q_\theta(s,a)$ parameterized by weights $\theta$.</p><p>The training procedure draws inspiration from supervised learning, specifically, from temporal difference (TD) learning. Here‚Äôs how it works:</p><p>We want to train $Q_\theta$ to satisfy the Bellman equation, so we construct a target value:</p>\[y(s, a) = r(s, a) + \gamma \max_{a'} Q_\theta(s', a')\]<p>The target itself involves our Q-function evaluated at the next state $s‚Äô$. This creates a ‚Äúbootstrap‚Äù situation where we‚Äôre using our current estimates to create training targets for future estimates.</p><p>We then define a TD-error loss function which we want to minimize:</p>\[\text{TD-Error}(\theta) = \mathbb{E}_{s, a, s' \sim \mathcal{D}} \left[ \left( Q_\theta(s, a) - y(s, a) \right)^2 \right]\]<p>The gradient update becomes:</p>\[\theta_{t+1} \leftarrow \theta_t - \alpha \nabla_\theta \text{TD-Error}(\theta) \big|_{\theta = \theta_t}\]<p>This is not gradient descent in the traditional sense. Why? Because our target $y(s,a)$ itself depends on $\theta$ through the $\max_{a‚Äô} Q_\theta(s‚Äô, a‚Äô)$ term. When we compute the gradient, we‚Äôre treating the target as fixed (not differentiating through it), but the target is actually moving as $\theta$ changes. This creates a moving target problem that can lead to instability.</p><p>Think of it like trying to hit a bullseye that keeps shifting position as you aim. Traditional supervised learning has a fixed target. But in Q-learning, as our Q-estimates get better, the targets we‚Äôre aiming for also change, creating a feedback loop that can sometimes diverge.</p><p>Despite this theoretical concern, fitted Q-iteration can work in practice with the right tricks. The key insight is that even though we‚Äôre not doing true gradient descent on a fixed objective, we‚Äôre still iteratively improving our Q-estimates to better satisfy the Bellman equation.</p><p><strong>Why the Q-Learning Target Makes Sense:</strong></p><p>The target $y(s, a) = r(s, a) + \gamma \max_{a‚Äô} Q(s‚Äô, a‚Äô)$ comes directly from the Bellman optimality equation. When you take action $a$ in state $s$, your total expected return naturally splits into two components: the immediate reward $r(s,a)$ you receive right now, and the best possible future value you can obtain from wherever you land next, which is $\gamma \max_{a‚Äô} Q(s‚Äô, a‚Äô)$. The max operator appears because we‚Äôre learning the optimal Q-function, which assumes we‚Äôll always choose the best action going forward, even if our current exploratory policy doesn‚Äôt actually do that yet.</p><p>This creates a bootstrapping process where we use our current value estimates to improve themselves. Even though our Q-estimates start out imperfect, we can make progress by using the estimate at the next state $s‚Äô$ to improve the estimate at the current state $s$. The one-step reward $r(s,a)$ provides accurate immediate information, and combining it with our (gradually improving) estimate of future value pushes our Q-function toward satisfying the Bellman equation. Over many iterations, these improvements propagate backward through the state space, eventually converging to the optimal Q-function.</p><p>The reason we take the max rather than averaging over our current policy‚Äôs action distribution is what makes Q-learning ‚Äúoff-policy‚Äù ‚Äî it learns about the optimal policy directly, regardless of how we‚Äôre actually behaving during data collection. This allows us to learn from exploratory or even random actions, since we‚Äôre always targeting what the best action would be, not what we actually did.</p><h2 id="deep-q-networks-dqn"><span class="mr-2">Deep Q-Networks (DQN)</span><a href="#deep-q-networks-dqn" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The breakthrough that made deep Q-learning practical came with the Deep Q-Network (DQN) algorithm, which introduced two critical innovations to address the instability issues.</p><h3 id="innovation-1-replay-buffer"><span class="mr-2">Innovation 1: Replay Buffer</span><a href="#innovation-1-replay-buffer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Instead of training on data as it comes from the agent‚Äôs current policy, DQN stores transitions <code class="language-plaintext highlighter-rouge">(s, a, r, s')</code> in a large replay buffer (essentially a dataset of experiences). During training, we sample random mini-batches from this buffer rather than using consecutive experiences.</p><p><strong>Why does this help?</strong></p><p>First, it breaks the correlation between consecutive samples. If we trained on experiences in the order they occurred, the network would see highly correlated data (e.g., many frames from the same episode of a game), which can lead to overfitting to recent experiences and catastrophic forgetting of earlier lessons. Random sampling from the replay buffer gives us more independent and identically distributed-like data, which neural networks handle much better.</p><p>Second, the replay buffer provides data efficiency. Each experience can be used for multiple gradient updates rather than being discarded after a single use. This is particularly valuable in domains where collecting data is expensive.</p><h3 id="innovation-2-target-networks"><span class="mr-2">Innovation 2: Target Networks</span><a href="#innovation-2-target-networks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>To address the moving target problem, DQN maintains two sets of Q-network parameters: the current network $\theta_t$ that we‚Äôre actively training, and a target network $\theta_t^{target}$ that we use to compute the targets in the Bellman equation.</p><p>The TD-error loss now becomes:</p>\[\min_\theta \mathbb{E}_{(s, a, r, s') \in \mathcal{D}} \left[ \left( Q_\theta(s, a) - \left( r(s, a) + \gamma \max_{a'} Q_{\theta_t^{\text{target}}}(s', a') \right) \right)^2 \right]\]<p>The key idea is that we update $\theta_t$ on every gradient step, but we only update the target network $\theta_t^{target}$ occasionally (e.g., every few thousand steps) by copying the current network weights. This creates a period of stability where the targets remain fixed while we train, reducing the moving target problem. It‚Äôs like the bullseye staying still for a while so we can actually learn to aim at it before it moves again.</p><h3 id="algorithm"><span class="mr-2">Algorithm</span><a href="#algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The complete DQN algorithm works as follows:</p><ol><li><p>Collect data using policy $\pi_{\theta_t}$ (typically $\epsilon-$greedy: take argmax action with probability $1-\epsilon$, and random action with probability $\epsilon$ for exploration by sampling from a uniform distribution of actions $\pi \sim \text{Unif}(\mathcal{A})$ ).</p>\[\pi(s) = \arg\max_{a'} Q_{\theta_t}(s, a')\]<li>Store transitions <code class="language-plaintext highlighter-rouge">(s, a, r, s')</code> in replay buffer $\mathcal{D}$<li><p>Sample mini-batch from $\mathcal{D}$ and perform gradient descent on:</p>\[\min_\theta \mathbb{E}_{(s, a, r, s') \in \mathcal{D}} \left[ \left( Q_\theta(s, a) - \left( r(s, a) + \gamma \max_{a'} Q_{\theta_t^{\text{target}}}(s', a') \right) \right)^2 \right]\]<li>Periodically update target network: every $K$ steps, set $\theta_t^{target} \leftarrow \theta_t$</ol><p>The use of soft targets (keeping the target network fixed for periods) combined with the replay buffer‚Äôs decorrelated sampling creates a much more stable training process than naive fitted Q-iteration. This allowed DQN to achieve superhuman performance on many Atari games, marking a major milestone in deep reinforcement learning.</p><p>The fundamental insight of DQN is that even though we‚Äôre not doing true gradient descent (since we‚Äôre using target networks and treating parts of our objective as fixed), we can still make meaningful progress by carefully managing the optimization process to reduce instability.</p><h3 id="key-hyperparameters-and-design-choices"><span class="mr-2">Key Hyperparameters and Design Choices</span><a href="#key-hyperparameters-and-design-choices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Update-to-Data (UTD) Ratio:</strong></p><p>The UTD ratio measures how many gradient updates we perform per environment step. If UTD = 1, we take one gradient step for each new transition we collect. If UTD = 4, we perform four gradient updates (sampling four different mini-batches from the replay buffer) for each new transition.</p><p>A higher UTD ratio means we‚Äôre extracting more learning from each piece of data, which can be sample-efficient. However, there‚Äôs a trade-off: if the UTD ratio is too high, we can overfit to the data in our replay buffer, and the rapid updates can destabilize training. The agent might start exploiting patterns in old data that are no longer relevant to the current policy. Selecting its value is problem-dependent, as there are cases where UTD is as high as 100, but sometimes as low as 0.001.</p><p>Example scenario for UTD=4. So the process looks like this:</p><ol><li>Agent takes one action in environment $\rarr$ gets one new transition $\rarr$ add it to replay buffer<li>Sample mini-batch #1 from replay buffer $\rarr$ compute loss $\rarr$ gradient step<li>Sample mini-batch #2 from replay buffer $\rarr$ compute loss $\rarr$ gradient step<li>Sample mini-batch #3 from replay buffer $\rarr$ compute loss $\rarr$ gradient step<li>Sample mini-batch #4 from replay buffer $\rarr$ compute loss $\rarr$ gradient step<li>Return to step 1, take another action in environment</ol><p>Those 4 gradient steps in the middle are all training on old data from the replay buffer, not on the single new transition we just collected. The new transition goes into the buffer and might get sampled in future mini-batches, but we‚Äôre primarily learning from historical experiences.</p><p><strong>Hard vs Soft Target Updates</strong></p><p>The target network update described above is called a ‚Äúhard update‚Äù, where we completely replace $\theta^{target}$ with $\theta$ all at once. An alternative approach is ‚Äúsoft updates,‚Äù where we gradually blend the target network toward the main network at every step:</p>\[\theta^{\text{target}}_{i+1} \leftarrow (1 - \alpha) \theta^{\text{target}}_i + \alpha \theta_i\]<p>Here $\alpha$ is a small constant like 0.005. This means the target network slowly tracks the main network, providing continuously updating targets rather than sudden jumps. Hard updates every $K$ steps with $K$ large create discrete jumps, while soft updates with small $\alpha$ create smooth tracking. Soft updates often provide more stable training because the targets change gradually rather than suddenly shifting every few thousand steps.</p><p>Note: You pick one strategy and stick with it throughout training. They‚Äôre two different design choices for solving the same problem (keeping targets stable), not complementary techniques you‚Äôd combine.</p><h2 id="challenges-with-dqn"><span class="mr-2">Challenges with DQN</span><a href="#challenges-with-dqn" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="challenge-1-overestimation-bias-in-q-values"><span class="mr-2">Challenge 1: Overestimation Bias in Q-Values</span><a href="#challenge-1-overestimation-bias-in-q-values" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>One of the major practical challenges with DQN is that it tends to systematically overestimate Q-values. This is a fundamental issue with how the algorithm compounds errors through bootstrapping.</p><p><strong>The Root Cause: Error Accumulation Through Max Operations</strong></p><p>Our target is:</p>\[y(s,a) = r(s,a) + \gamma \max_{a'} Q_{\theta^{\text{target}}}(s', a')\]<p>The term $\max_{a‚Äô} Q_{\theta^{target}}(s‚Äô, a‚Äô)$ is supposed to represent the optimal state value $V^*(s‚Äô)$, which is the true value we‚Äôd get by following the optimal policy from state $s‚Äô$ onward. However, our Q-function $Q_{\theta^{target}}$ is not perfect and has some errors. Some actions might have Q-values that are too high (overestimates), while others might be too low (underestimates).</p><p>This problem becomes serious because we‚Äôre doing bootstrapping ‚Äî the Q-value we‚Äôre training becomes the target for earlier states. So if $Q_\theta(s‚Äô, a‚Äô)$ is overestimated, then when we compute the target for state $s$, we use this overestimate. This means $Q_\theta(s, a)$ will also become overestimated. Then when we compute targets for states that lead to $s$, they inherit this error, and so on. The overestimation compounds backward through the state space like a chain reaction.</p><p><strong>Double DQN: Decoupling Action Selection and Evaluation</strong></p><p>The problem is that we‚Äôre using the same Q-function both to select which action looks best AND to evaluate how good that action is. This creates the bias‚Äîwe pick the action with the largest estimation error, then trust that error as our target.</p><p>Double DQN fixes this by maintaining two Q-functions (initialized differently): $Q_{\theta^A}$ and $Q_{\theta^B}$. The key idea is to use one network to select the action and the other network to evaluate it. Here‚Äôs how the target computation changes:</p><ol><li><p>Use network A to determine which action looks best in state $s‚Äô$:</p>\[a^* = \arg\max_{a} Q_{\theta^A}(s', a)\]<li><p>Use network B to evaluate that specific action:</p>\[y(s,a) = r(s,a) + \gamma Q_{\theta^B}(s', a^*)\]</ol><p>Why does this help? If network A has a positive error on some action (thinks it‚Äôs better than it really is), it will select that action. But then network B evaluates it, and B‚Äôs errors are independent of A‚Äôs errors (since they were initialized differently and trained on different mini-batches). So B is unlikely to have the same overestimation for that same action. On average, this decorrelates the selection bias from the evaluation bias, dramatically reducing the systematic overestimation.</p><p>In practice with DQN, we already have two networks‚Äîthe main network $\theta$ and the target network $\theta^{target}$ ‚Äî so we can implement Double DQN without adding any extra parameters. We use the main network to select actions and the target network to evaluate them:</p>\[a^* = \arg\max_{a} Q_{\theta}(s', a)\] \[y(s,a) = r(s,a) + \gamma Q_{\theta^{\text{target}}}(s', a^*)\]<h3 id="challenge-2-reducing-error-compounding-with-n-step-returns"><span class="mr-2">Challenge 2: Reducing Error Compounding with N-Step Returns</span><a href="#challenge-2-reducing-error-compounding-with-n-step-returns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Another approach to reducing error accumulation is to use N-step returns instead of one-step TD targets. The standard DQN target uses only one step of real reward before bootstrapping:</p>\[y(s,a) = r(s,a) + \gamma \max_{a'} Q_{\theta^{\text{target}}}(s', a')\]<p>This means we trust the immediate reward $r(s,a)$ (which comes from the environment and is accurate), but then immediately rely on our Q-function estimate for everything after. If our Q-estimates are poor, this propagates error quickly.</p><p>With N-step returns, we instead accumulate N steps of actual rewards before bootstrapping. If we have a trajectory <code class="language-plaintext highlighter-rouge">(s, a, r, s', a', r', s'', ...)</code> in our replay buffer, we can construct an N-step target:</p>\[y_N(s,a) = r(s,a) + \gamma r(s', a') + \gamma^2 r(s'', a'') + \cdots + \gamma^N \max_{a} Q_{\theta^{\text{target}}}(s_{N+1}, a)\]<p>The intuition is that we‚Äôre trusting real data for longer before falling back on our potentially erroneous estimates.</p><p>The trade-off is that N-step returns introduce higher variance ‚Äî they depend on N different random rewards and state transitions ‚Äî and they can only be computed for transitions where we have N subsequent steps stored in the replay buffer. But when tuned properly, they often significantly improve learning by reducing the impact of Q-value errors on the targets. The most common value of N used in practice is 3.</p><h3 id="challenge-3-cold-start-problem"><span class="mr-2">Challenge 3: Cold Start Problem</span><a href="#challenge-3-cold-start-problem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>At the very beginning of training, the replay buffer is empty, so DQN cannot perform any updates. The solution is a burn-in phase: before any Q-network training begins, the agent collects an initial dataset by acting in the environment for thousands of steps using either a random policy or highly exploratory $\epsilon-$greedy policy. This fills the replay buffer with diverse experiences. Only after this warm-up period do gradient updates begin. The Q-network starts with random weights and poor predictions, but it now has real environmental data to learn from.</p><h3 id="challenge-4-the-limited-exploration-problem"><span class="mr-2">Challenge 4: The Limited Exploration Problem</span><a href="#challenge-4-the-limited-exploration-problem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A more persistent challenge arises when the agent repeatedly visits similar states and fails to explore broadly. This can happen if the policy is too exploitative ($\epsilon$ too small), if certain states act as ‚Äúattractors‚Äù where the agent gets stuck, or if the state space is so vast that the explored region remains limited. When the replay buffer lacks diversity, the Q-function becomes specialized to only the visited states and performs poorly elsewhere, trapping the agent in a local optimum where its policy keeps leading it back to the same familiar territory.</p><p>This is why $\epsilon-$greedy exploration is essential throughout training. With probability $\epsilon$, the agent takes random actions instead of greedy ones, occasionally forcing it out of comfortable patterns and into new situations. In practice, $\epsilon$ typically starts at 1.0 during burn-in, then gradually decays to a small constant like 0.1 or 0.05. This schedule prioritizes early exploration to build buffer diversity, then shifts toward exploitation as the Q-function improves, while maintaining baseline exploration indefinitely to prevent getting stuck. Even a small constant $\epsilon$, over millions of steps, generates enough random detours to gradually expand the explored region and diversify the replay buffer.</p><h2 id="practical-training-details-for-dqn"><span class="mr-2"><strong>Practical Training Details for DQN</strong></span><a href="#practical-training-details-for-dqn" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A few additional implementation details that significantly impact DQN‚Äôs performance:</p><p><strong>Coverage Really Helps:</strong> Ensuring broad state-space coverage through effective exploration is crucial. If the replay buffer only contains data from a limited region of the state space, the Q-function will have poor estimates elsewhere, and the agent may fail to discover better behaviors. Techniques like decaying $\epsilon$ over time (starting with high exploration, gradually reducing it as we learn) help balance initial exploration with later exploitation.</p><p><strong>High UTD Can Destabilize Training:</strong> While performing many gradient updates per environment step seems attractive for sample efficiency, setting the UTD ratio too high can cause instability. The agent essentially overfits to its replay buffer, and rapid Q-value changes can violate the assumptions that make target networks helpful. Conservative UTD ratios tend to be more robust.</p><p><strong>Improved Loss Functions:</strong> Instead of using standard squared error, practitioners often use the Huber loss, which is quadratic for small errors but linear for large errors:</p>\[L(x) = \begin{cases}\frac{x^2}{2}, &amp; |x| \leq \delta \\\delta |x| - \frac{\delta^2}{2}, &amp; |x| &gt; \delta\end{cases}\]<p>In the context of DQN, $x$ represents the TD-error:</p>\[x = Q_{\theta}(s,a) - \left( r + \gamma \max_{a'} Q_{\theta^{\text{target}}}(s', a') \right)\]<p>$\delta(x)$ is a hyperparameter that we choose.</p><p>This makes training more robust to outliers and large TD-errors, which can occur especially early in training when Q-estimates are poor. The Huber loss prevents single large errors from causing dramatic parameter updates that destabilize learning.</p><h2 id="understanding-vs-in-value-based-rl"><span class="mr-2">Understanding $V(s)$ in Value-Based RL</span><a href="#understanding-vs-in-value-based-rl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="vs-is-implicitly-computed-not-separately-stored"><span class="mr-2">$V(s)$ is Implicitly Computed, Not Separately Stored</span><a href="#vs-is-implicitly-computed-not-separately-stored" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In DQN, we only learn the Q-function $Q_\theta(s,a)$ using a neural network. We don‚Äôt maintain a separate value function. However, $V(s)$ isn‚Äôt missing. It is simply computed implicitly whenever we need it through the relationship:</p>\[V(s) = \max_a Q_\theta(s, a)\]<p>This means $V(s)$ automatically stays synchronized with our Q-values. Every time the parameters $\theta$change and our Q-function improves, the value function $V(s)$ implicitly changes along with it because it‚Äôs derived from the Q-values. We‚Äôre not storing two separate functions that could fall out of sync; we‚Äôre storing one function (Q) and computing the other (V) from it on-demand (if at all needed).</p><h3 id="why-advantages-and-q-values-lead-to-the-same-policy"><span class="mr-2">Why Advantages and Q-Values Lead to the Same Policy</span><a href="#why-advantages-and-q-values-lead-to-the-same-policy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The advantage function is defined as $A(s,a) = Q(s,a) - V(s)$. You might wonder whether we should be taking the argmax over advantages or over Q-values. The answer is that it doesn‚Äôt matter, since they give the same result.</p><p>When we‚Äôre selecting an action, we compute $\argmax_a A(s,a) = \argmax_a [Q(s,a) - V(s)]$. The critical observation is that $V(s)$ is the same value for all actions in state $s$ at any given moment in time. Since $V(s)$ doesn‚Äôt depend on which action we‚Äôre considering, it‚Äôs just a constant that gets subtracted from all Q-values equally. Adding or subtracting the same constant from every option doesn‚Äôt change which option is largest, so:</p>\[\argmax_a [Q(s,a) - V(s)] = \argmax_a Q(s,a)\]<p>This is why DQN can work directly with Q-values for action selection without ever explicitly computing advantages. The policy is simply:</p>\[\pi(s) = \argmax_a Q_\theta(s,a)\]<h1 id="advanced-policy-gradients-bridging-policy-based-and-value-based-methods">Advanced Policy Gradients: Bridging Policy-Based and Value-Based Methods</h1><h2 id="motivation"><span class="mr-2">Motivation</span><a href="#motivation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Up to this point, we‚Äôve studied two distinct families of reinforcement learning algorithms. Policy gradient methods learn an explicit policy (perhaps with an on-policy value function for variance reduction), and they‚Äôre fundamentally on-policy ‚Äî they must collect data using the current policy being optimized. Value-based methods like Q-learning don‚Äôt maintain an explicit policy at all; instead, they learn a value function and derive the policy implicitly through argmax operations, which allows them to be off-policy and leverage replay buffers for sample efficiency.</p><p>A natural question arises: can we build a hybrid that combines the best of both worlds? Such an algorithm should be off-policy to benefit from replay buffers and reuse old data, yet it should maintain an explicit policy network that we can optimize using actor-critic style updates. This would give us the expressiveness and continuous action handling of policy gradients with the sample efficiency of value-based methods. The answer is yes, and this leads us to a family of algorithms called off-policy policy gradient methods. The challenge is: how do we derive a principled way to make this work?</p><h2 id="the-performance-difference-lemma"><span class="mr-2">The Performance Difference Lemma</span><a href="#the-performance-difference-lemma" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The key mathematical tool that enables off-policy policy gradients is the Performance Difference Lemma. This lemma provides an exact relationship between the performance of any two policies $\pi$ and $\mu$.</p><p>Recall that the advantage function for a policy $\mu$ is defined as:</p><aside> üí° $$ A^{\mu}(s, a) = Q^{\mu}(s, a) - V^{\mu}(s) $$</aside><p>This measures how much better action $a$ is compared to the average value of being in state $s$ under policy $\mu$. Importantly, we have the property that the expected advantage under the policy‚Äôs own action distribution is zero:</p><aside> üí° $$ \mathbb{E}_{a \sim \mu(\cdot|s)} [A^{\mu}(s, a)] = 0 $$</aside><p>This is because when we average the advantage over all actions weighted by how often the policy takes them, the positive and negative deviations from the mean cancel out.</p><p>Now, the Performance Difference Lemma states that for any two policies $\pi$ (the policy we‚Äôre evaluating) and $\mu$ (some other policy), the difference in their expected returns can be expressed as:</p><aside> üí° $$ J(\pi) - J(\mu) = \mathbb{E}_{\tau \sim P_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t A^{\mu}(s_t, a_t) \right] $$</aside><p><strong>What the above equation means:</strong> The trajectories $\tau$ are generated by following policy $\pi$ (so states are distributed according to $\pi$‚Äôs state visitation), but the advantages being summed are computed with respect to policy $\mu$. It connects the performance of $\pi$ to advantages measured under a different policy $\mu$.</p><p><strong>Why is this useful?</strong> This lemma tells us that to improve $\pi$ relative to $\mu$, we want to maximize the expected sum of $\mu$‚Äôs advantages along trajectories generated by $\pi$. If we can accurately estimate $A^\mu$ (using a critic), we can optimize $\pi$ to take actions that have high advantage according to $\mu$.</p><h3 id="derivation-2"><span class="mr-2">Derivation</span><a href="#derivation-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>We start with the definition of the return:</p>\[J(\pi) = \mathbb{E}_{\tau \sim p_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t r(s_t, a_t) \right]\]<p>Now, notice that the entire sum of rewards is just $V^\pi(s_0)$, the value of the initial state under policy $\pi$. So we can write:</p>\[J(\pi) = \mathbb{E}_{s_0 \sim p(s_0)} [V^{\pi}(s_0)]\]<p>The key insight here is that the trajectory distribution $p_\pi(\tau)$ can be decomposed: first we sample $s_0$ from some initial state distribution $p(s_0)$, and then the rest of the trajectory unfolds according to $\pi$. Since $s_0$ is sampled independently of the policy, the expectation over trajectories becomes an expectation over just the initial state.</p><p>Similarly, for policy $\mu$:</p>\[J(\mu) = \mathbb{E}_{s_0 \sim p(s_0)} [V^{\mu}(s_0)]\]<p>Now let‚Äôs compute the difference:</p>\[J(\pi) - J(\mu) = \mathbb{E}_{s_0 \sim p(s_0)} [V^{\pi}(s_0)] - \mathbb{E}_{s_0 \sim p(s_0)} [V^{\mu}(s_0)]\]<p>Since both expectations are over the same distribution, we can combine them:</p>\[J(\pi) - J(\mu) = \mathbb{E}_{s_0 \sim p(s_0)} [V^{\pi}(s_0) - V^{\mu}(s_0)]\]<p>We want to express this difference in terms of advantages. To do this, we need to ‚Äúunroll‚Äù the value function recursively using the Bellman equation.</p><p>Recall the Bellman equation for $V^\pi$:</p>\[V^{\pi}(s) = \mathbb{E}_{a \sim \pi(\cdot|s), s' \sim p(\cdot|s,a)} [r(s,a) + \gamma V^{\pi}(s')]\]<p>Let‚Äôs apply this to $s_0$:</p>\[V^{\pi}(s_0) = \mathbb{E}_{a_0 \sim \pi(\cdot|s_0), s_1 \sim p(¬∑|s_0, a_0)} [r(s_0, a_0) + \gamma V^{\pi}(s_1)]\]<p>Now we want to introduce $V^\mu$ into this expression. Notice that we can write:</p>\[V^{\pi}(s_0) - V^{\mu}(s_0) = \mathbb{E}_{a_0 \sim \pi, s_1} [r(s_0, a_0) + \gamma V^{\pi}(s_1)] - V^{\mu}(s_0)\] \[V^{\pi}(s_0) - V^{\mu}(s_0) = \mathbb{E}_{a_0 \sim \pi, s_1} [r(s_0, a_0) + \gamma V^{\pi}(s_1) - \gamma V^{\mu}(s_1) + \gamma V^{\mu}(s_1)] - V^{\mu}(s_0)\]<p>Rearranging:</p>\[V^{\pi}(s_0) - V^{\mu}(s_0) = \mathbb{E}_{a_0 \sim \pi, s_1} [r(s_0, a_0) + \gamma V^{\mu}(s_1) - V^{\mu}(s_0) + \gamma(V^{\pi}(s_1) - V^{\mu}(s_1))]\]<p>Recall that:</p>\[A^{\mu}(s_0, a_0) = Q^{\mu}(s_0, a_0) - V^{\mu}(s_0) = r(s_0, a_0) + \gamma V^{\mu}(s_1) - V^{\mu}(s_0)\] \[V^{\pi}(s_0) - V^{\mu}(s_0) = \mathbb{E}_{a_0 \sim \pi, s_1} [A^{\mu}(s_0, a_0) + \gamma(V^{\pi}(s_1) - V^{\mu}(s_1))]\]<p>Now we have a recursive structure. The last term $\gamma (V^\pi(s_1) - V^\mu(s_1))$ has the same form as what we started with, just at time step 1 instead of time step 0. We can apply the same trick again:</p>\[V^{\pi}(s_1) - V^{\mu}(s_1) = \mathbb{E}_{a_1 \sim \pi, s_2} [A^{\mu}(s_1, a_1) + \gamma(V^{\pi}(s_2) - V^{\mu}(s_2))]\]<p>Substituting this back:</p>\[V^{\pi}(s_0) - V^{\mu}(s_0) = \mathbb{E}_{a_0 \sim \pi, s_1} [A^{\mu}(s_0, a_0) + \gamma \mathbb{E}_{a_1 \sim \pi, s_2} [A^{\mu}(s_1, a_1) + \gamma(V^{\pi}(s_2) - V^{\mu}(s_2))]]\]<p>Distributing the outer expectation and the $\gamma$:</p>\[V^{\pi}(s_0) - V^{\mu}(s_0) = \mathbb{E}_{a_0 \sim \pi, s_1} [A^{\mu}(s_0, a_0)] + \gamma \mathbb{E}_{a_0 \sim \pi, s_1, a_1 \sim \pi, s_2} [A^{\mu}(s_1, a_1)] + \gamma^2 \mathbb{E}_{...} [V^{\pi}(s_2) - V^{\mu}(s_2)]\]<p>If we keep expanding this pattern infinitely (which is valid as long as $\gamma &lt;1$ ensures convergence), we get:</p>\[V^{\pi}(s_0) - V^{\mu}(s_0) = \sum_{t=0}^{\infty} \gamma^t \mathbb{E}_{s_0, a_0, s_1, a_1, ..., s_t, a_t} [A^{\mu}(s_t, a_t)]\]<div class="table-wrapper"><table><tbody><tr><td>where the expectation is taken over trajectories generated by policy $\pi$ (so $s_0 \sim p(s_0)$, then $a_0 \sim \pi(\cdot<td>s_0)$, then $s_1 \sim p(\cdot<td>s_0,a_0)$, and so on).</table></div><p>We can write this more compactly as:</p>\[V^{\pi}(s_0) - V^{\mu}(s_0) = \mathbb{E}_{\tau \sim p_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t A^{\mu}(s_t, a_t) \right]\]<p>Finally, we take the expectation over the initial state distribution:</p>\[J(\pi) - J(\mu) = \mathbb{E}_{s_0 \sim p(s_0)} [V^{\pi}(s_0) - V^{\mu}(s_0)]\] \[= \mathbb{E}_{s_0 \sim p(s_0)} \left[ \mathbb{E}_{\tau \sim p_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t A^{\mu}(s_t, a_t) \right] \right]\] \[J(\pi) - J(\mu) = \mathbb{E}_{\tau \sim p_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t A^{\mu}(s_t, a_t) \right]\]<h2 id="the-optimization-problem"><span class="mr-2">The Optimization Problem</span><a href="#the-optimization-problem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The Performance Difference Lemma gives us an exact expression for $J(\pi) - J(\mu)$, but how do we use this to actually optimize $\pi$? We can frame this as a constrained optimization problem:</p><aside> üí° $$ \max_{\pi} \left( J(\pi) - J(\mu) \right) = \max_{\pi} \mathbb{E}_{\tau \sim p_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t A^{\mu}(s_t, a_t) \right] $$</aside><p>But there‚Äôs a catch: the expectation is over trajectories sampled from $\pi$. This means to evaluate this expression, we need to actually run policy $\pi$ in the environment, collect full trajectories, and compute advantages along those trajectories. Every time we update $\pi$, we‚Äôd need fresh data from the new $\pi$. This is on-policy learning, and it is sample-inefficient because we can‚Äôt reuse old data.</p><p>When we write $\tau \sim p_\pi(\tau)$, we‚Äôre sampling an entire trajectory according to $\pi$‚Äôs distribution. But what does this really mean? A trajectory is a sequence $(s_0, a_0, s_1, a_1, s_2, a_2, ‚Ä¶)$, and the distribution over trajectories can be factored:</p><ul><li>First, we sample $s_0$ from the initial state distribution $p(s_0)$<li><div class="table-wrapper"><table><tbody><tr><td>Then we sample $a_0$ from $\pi(\cdot<td>s_0)$</table></div><li><div class="table-wrapper"><table><tbody><tr><td>Then the environment gives us $s_1$ from $p(\cdot<td>s_0, a_0)$</table></div><li><div class="table-wrapper"><table><tbody><tr><td>Then we sample $a_1$ from $\pi(\cdot<td>s_1)$</table></div><li>And so on‚Ä¶</ul><p>The key is that which states we visit is determined by the policy. Policy $\pi$ creates a specific pattern of state visitation over time. We call this the ‚Äústate visitation distribution‚Äù or ‚Äústate marginal distribution‚Äù and denote it $p_\pi(s_t)$ for time step $t$, or more generally $d^\pi(s)$ for the discounted state visitation.</p><p>Here‚Äôs where we make a crucial approximation that enables off-policy learning. Instead of collecting data under $\pi$ (the policy we‚Äôre optimizing), we can collect data under $\mu$ (some behavioral policy, perhaps an older version of $\pi$) and correct for the distribution mismatch. We rewrite the expectation over $\pi$‚Äôs trajectories as:</p><aside> üí° $$ \mathbb{E}_{\tau \sim p_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t A^{\mu}(s_t, a_t) \right] \approx \sum_{t=0}^{\infty} \mathbb{E}_{s_t \sim p_{\mu}(s_t)} \left[ \mathbb{E}_{a_t \sim \pi(\cdot|s_t)} [\gamma^t A^{\mu}(s_t, a_t)] \right] $$</aside><p>This approximation says: instead of following $\pi$‚Äôs entire trajectory distribution (which determines which states we visit), we use states visited by $\mu$, but we still choose actions according to $\pi$ at each state. The key insight is that when $\pi$ and $\mu$ are close (which we‚Äôll enforce with a constraint), the states visited by the two policies are similar, so this approximation is reasonable.</p><p>Now the inner expectation only involves sampling actions from $\pi$ given states from $\mu$‚Äôs distribution:</p>\[\mathbb{E}_{s \sim d^{\mu}(s)} \left[ \mathbb{E}_{a \sim \pi(\cdot|s)} [A^{\mu}(s, a)] \right]\]<p>where $d^\mu(s)$ represents the discounted state visitation distribution under policy $\mu$. This is something we can estimate from a replay buffer filled with $\mu$‚Äôs experiences.</p><p>We add a constraint to keep $\pi$ close to $\mu$, typically measured by a divergence $D(\pi,\mu)$. This gives us the constrained optimization problem:</p><aside> üí° $$ \max_{\pi} \mathbb{E}_{s \sim d^{\mu}(s)} \left[ \mathbb{E}_{a \sim \pi(\cdot|s)} [A^{\mu}(s, a)] - \alpha D(\pi, \mu)\right] $$</aside><p>where $\alpha$ controls how much we penalize deviation from $\mu$. The divergence $D$ can be chosen in different ways, such as KL divergence, total variation distance, etc., and each choice leads to a different algorithm.</p><div class="table-wrapper"><table><tbody><tr><td>If $D(\pi(\cdot<td>s), \mu(\cdot<td>s))$ is small, then it implies that $p_\pi(s) \sim p_\mu(s)$.</table></div><h3 id="some-additional-math"><span class="mr-2">Some Additional Math</span><a href="#some-additional-math" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><aside> üí° $$ \mathbb{E}_{\tau \sim p_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t f(s_t, a_t) \right] = \frac{1}{1-\gamma} \mathbb{E}_{s \sim d^{\pi}(s)} \left[ \mathbb{E}_{a \sim \pi(\cdot|s)} [f(s,a)] \right] $$</aside><p>The left side sums over time steps in a trajectory. The right side removes the explicit time dependence by using the discounted state visitation distribution $d^\pi(s)$.</p><p>The discounted state visitation distribution $d^\pi(s)$ is defined as:</p><aside> üí° $$ d^{\pi}(s) = (1-\gamma) \sum_{t=0}^{\infty} \gamma^t p_{\pi}(s_t = s) $$</aside><p>This is a distribution (not just a sum) because of the normalization factor $(1-\gamma)$. It represents ‚Äúhow often do we visit state $s$, weighted by how far in the future it is.‚Äù The factor $(1-\gamma)$ ensures that when we sum over all states $s$, we get $1$ (a valid probability distribution).</p><p>Let‚Äôs start with the left side and manipulate it:</p>\[\mathbb{E}_{\tau \sim p_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t f(s_t, a_t) \right]\] \[= \sum_{t=0}^{\infty} \gamma^t \mathbb{E}_{\tau \sim p_{\pi}(\tau)} [f(s_t, a_t)]\] \[= \sum_{t=0}^{\infty} \gamma^t \mathbb{E}_{s_t \sim p_{\pi}(s_t)} \left[ \mathbb{E}_{a_t \sim \pi(\cdot|s_t)} [f(s_t, a_t)] \right]\]<p>Here $p_\pi(s_t)$ is the marginal distribution over states at time $t$ when following policy $\pi$.</p><p>Now multiply and divide by $(1-\gamma)$:</p>\[= \frac{1}{1-\gamma} \sum_{t=0}^{\infty} (1-\gamma) \gamma^t \mathbb{E}_{s_t \sim p_{\pi}(s_t)} \left[ \mathbb{E}_{a_t \sim \pi(\cdot|s_t)} [f(s_t, a_t)] \right]\]<p>By the definition of $d^\pi(s)$, we can write:</p>\[\sum_{t=0}^{\infty} (1-\gamma) \gamma^t \mathbb{E}_{s_t \sim p_{\pi}(s_t)} [g(s_t)] = \mathbb{E}_{s \sim d^{\pi}(s)} [g(s)]\]<p>This is because:</p>\[\mathbb{E}_{s \sim d^{\pi}(s)} [g(s)] = \sum_s d^{\pi}(s) g(s) = \sum_s \left[ (1-\gamma) \sum_{t=0}^{\infty} \gamma^t p_{\pi}(s_t=s) \right] g(s)\]<p>Rearranging the sums:</p>\[= \sum_{t=0}^{\infty} (1-\gamma) \gamma^t \sum_s p_{\pi}(s_t=s) g(s) = \sum_{t=0}^{\infty} (1-\gamma) \gamma^t \mathbb{E}_{s_t \sim p_{\pi}(s_t)} [g(s_t)]\]<div class="table-wrapper"><table><tbody><tr><td>Applying this to our case where $g(s) = E_{a \sim \pi(¬∑<td>s)}[f(s,a)]$:</table></div>\[= \frac{1}{1-\gamma} \mathbb{E}_{s \sim d^{\pi}(s)} \left[ \mathbb{E}_{a \sim \pi(\cdot|s)} [f(s,a)] \right]\]<p>This identity is useful because it converts a time-dependent sum (iterating through a trajectory) into a time-independent expectation over states. Instead of thinking about ‚Äúwhat happens at time 0, time 1, time 2, etc.‚Äù, we think about ‚Äúwhat happens in state $s$, weighted by how often we visit that state.‚Äù This is often more convenient for analysis and for designing algorithms.</p><p>So we have:</p><aside> üí° $$ J(\pi) - J(\mu) = \mathbb{E}_{\tau \sim p_{\pi}(\tau)} \left[ \sum_{t=0}^{\infty} \gamma^t A^{\mu}(s_t, a_t) \right] = \frac{1}{1-\gamma} \mathbb{E}_{s \sim d^{\pi}(s)} \left[ \mathbb{E}_{a \sim \pi(\cdot|s)} [A^\mu(s,a)] \right] $$</aside><h2 id="different-divergence-choices-lead-to-different-algorithms"><span class="mr-2">Different Divergence Choices Lead to Different Algorithms</span><a href="#different-divergence-choices-lead-to-different-algorithms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The natural choice of divergence here is the Total Variation (TV) distance between the two policy distributions.</p>\[D(\pi,\mu) = D_{TV}(\pi(\cdot|s), \mu(\cdot|s))\]<p>The total variation distance between two probability distributions $p$ and $q$ over a space $\mathcal{X}$ is defined as:</p>\[D_{TV}(p(\cdot), q(\cdot)) = \sum_{x \in \mathcal{X}} |p(x) - q(x)|\] \[D_{TV}(p(\cdot), q(\cdot)) = \int_x |p(x) - q(x)| \, dx\]<div class="table-wrapper"><table><tbody><tr><td><strong>Intuition:</strong> At every single point x in your space, you measure how much $p$ and $q$ disagree at that point, and that‚Äôs just $<td>p(x) - q(x)<td>$. Then you sum up all these local disagreements across the entire space. The result is the total amount by which the two distributions differ from each other.</table></div><p>But since it is very hard to compute the total variation distance in a very large action space using sampling, we look at other methods for estimating this.</p><p>The choice of divergence measure $D(\pi,\mu)$ significantly impacts the resulting algorithm and its properties:</p><div class="table-wrapper"><table><tbody><tr><td>**Choice 1: $D_{KL}(\pi<td>¬†<td>\mu)$ :** This is the KL divergence from $\pi$ to $\mu$, measuring how much information is lost when using $\mu$ to approximate $\pi$. Using this divergence leads to the <strong>AWR (Advantage Weighted Regression)</strong> algorithm.</table></div><div class="table-wrapper"><table><tbody><tr><td>**Choice 2: $D_{KL}(\mu<td>¬†<td>\pi)$ :** This is the reverse KL divergence, from $\mu$ to $\pi$. Using this divergence leads to <strong>PPO (Proximal Policy Optimization)</strong> and <strong>TRPO (Trust Region Policy Optimization)</strong> algorithms.</table></div>\[D_{KL}(p||q) = \sum_\mathcal{X} p(x) \log{\frac{p(x)}{q(x)}}\] \[D_{KL}(p||q) = \int_x p(x) \log{\frac{p(x)}{q(x)}}\]<p>The mathematical properties of these divergences are different. The KL divergence satisfies several useful inequalities, particularly Pinsker‚Äôs inequality, which relates KL divergence to total variation distance:</p>\[D_{TV}(p, q) \leq \sqrt{\frac{1}{2} D_{KL}(p || q)}\] \[D_{TV}(p, q) \leq \sqrt{\frac{1}{2} D_{KL}(q || p)}\]<p>These relationships help bound how different the state distributions under $\pi$ and $\mu$ can be, which justifies the approximation we made earlier.</p><h2 id="advantage-weighted-regression-awr"><span class="mr-2">Advantage Weighted Regression (AWR)</span><a href="#advantage-weighted-regression-awr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="table-wrapper"><table><tbody><tr><td>AWR is the algorithm that arises when we choose $D_KL(\pi<td>¬†<td>\mu)$ as our divergence measure ‚Äî that is, we penalize $\pi$ for being too different from $\mu$ in the ‚Äúforward‚Äù KL direction.</table></div><p>The key insight of AWR is that this constrained optimization problem ‚Äî maximizing the expected advantage while staying close to $\mu$ in KL divergence ‚Äî has an analytical solution. We don‚Äôt need to run gradient descent on this objective; we can directly write down what the optimal policy looks like.</p><p>To see why, let‚Äôs think about a simpler version of the problem. Suppose we want to find a distribution $p(x)$ that maximizes the expected value of some function $f(x)$, while staying close to some reference distribution $q(x)$ in KL divergence:</p>\[\max_{p(x)} \mathbb{E}_{x \sim p(x)} [f(x)] - \alpha D_{KL}(p \| q)\]<p>This is a standard problem in variational inference, and its solution is:</p>\[p^*(x) \propto q(x) \exp\left(\frac{f(x)}{\alpha}\right)\]<p>The optimal distribution is the reference distribution $q$, reweighted by the exponential of the function $f$, scaled by $1/\alpha$. Intuitively, this makes sense: we start from $q$ and upweight regions where $f$ is large (good actions) and downweight regions where $f$ is small (bad actions), with $\alpha$ controlling how aggressively we do this reweighting.</p><p>Applying this general solution to our policy optimization problem, where $p$ is $\pi$, $q$ is $\mu$, and $f(x)$ is $A^\mu(s,a)$, we get the optimal policy:</p>\[\pi^*(a|s) \propto \mu(a|s) \exp\left(\frac{A^{\mu}(s, a)}{\alpha}\right)\]<p>This is the AWR oracle solution. The optimal policy takes the behavior policy $\mu$ and reweights each action by the exponential of its advantage under $\mu$, scaled by the temperature parameter $\alpha$. Actions with high positive advantage (much better than average) get upweighted exponentially, while actions with negative advantage (worse than average) get downweighted exponentially.</p><p>The temperature $\alpha$ controls the sharpness of this reweighting. A very small $\alpha$ makes the exponential very peaked, concentrating all the probability mass on the single best action (approaching a deterministic greedy policy). A large $\alpha$ makes the exponential flat, keeping the policy close to $\mu$ regardless of the advantages (safe but slow improvement).</p><h3 id="how-do-we-actually-use-this-oracle-solution"><span class="mr-2">How Do We Actually Use This Oracle Solution?</span><a href="#how-do-we-actually-use-this-oracle-solution" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><tbody><tr><td>The optimal policy $\pi^*(a<td>s) \propto \mu(a<td>s) \exp(A^\mu(s,a)/\alpha)$ is not directly a neural network we can deploy, it‚Äôs defined implicitly through this proportionality relationship. We need to find a way to fit a practical parameterized policy $\pi_\theta$ to this oracle.</table></div><p>We use regression: we find the parameters $\theta$ that make $\pi_\theta$ as close as possible to $\pi^*$ by minimizing the KL divergence between them. This is equivalent to maximum likelihood estimation, where the ‚Äúlabels‚Äù are the exponential weights:</p>\[\max_{\theta} \mathbb{E}_{s \sim d^{\mu}(s)} \left[ \mathbb{E}_{a \sim \mu(\cdot|s)} \left[ \exp\left(\frac{A^{\mu}(s,a)}{\alpha}\right) \log \pi_{\theta}(a|s) \right] \right]\]<div class="table-wrapper"><table><tbody><tr><td>This is where the name ‚ÄúAdvantage Weighted Regression‚Äù comes from. We‚Äôre doing a weighted regression of $\log \pi_\theta(a<td>s)$, where the weights are the exponentiated advantages $\exp(A^\mu(s,a)/\alpha)$. Actions that were particularly good (high advantage) contribute more to the regression loss, effectively pushing the policy to assign higher probability to those actions.</table></div><h3 id="the-practical-awr-algorithm"><span class="mr-2">The Practical AWR Algorithm</span><a href="#the-practical-awr-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Putting this all together, the AWR algorithm works as follows. First we collect data using the current behavior policy $\mu$ and store transitions in a replay buffer. We then train a critic to estimate the advantage function $A^\mu(s,a)$ from this data. Finally we update the policy by solving the weighted regression problem:</p>\[\max_{\theta} \mathbb{E}_{(s,a) \sim \mathcal{D}} \left[ \exp\left(\frac{A^{\mu}(s,a)}{\alpha}\right) \log \pi_{\theta}(a|s) \right]\]<p>where the expectation is taken over state-action pairs sampled from the replay buffer $\mathcal{D}$. This is just a weighted maximum likelihood problem ‚Äî we‚Äôre fitting the policy to the data, but upweighting good actions and downweighting bad ones according to their exponentiated advantages.</p><h3 id="why-awr-is-off-policy"><span class="mr-2">Why AWR is Off-Policy</span><a href="#why-awr-is-off-policy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Notice that nowhere in the final objective do we need to sample new actions from $\pi$. We use actions that were already stored in the replay buffer (sampled from $\mu$). This makes AWR genuinely off-policy: we can collect a large dataset using any behavior policy, train a critic on that dataset, and then improve the policy using weighted regression on the same dataset. We can even reuse old data from earlier versions of the policy, just like DQN‚Äôs replay buffer.</p><p>This is the major practical advantage of AWR over standard policy gradient methods. Standard REINFORCE or actor-critic methods must discard old data after each policy update (since the gradient estimates are only valid for the current policy). AWR can reuse all historical data, making it much more sample efficient.</p><h3 id="the-role-of-temperature-alpha"><span class="mr-2">The Role of Temperature $\alpha$</span><a href="#the-role-of-temperature-alpha" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The temperature parameter $\alpha$ plays a crucial role that‚Äôs worth understanding deeply. When $\alpha$ is very small, the exponential weights become very large for positive advantage actions and very small for negative advantage ones. The policy update becomes aggressive ‚Äî it strongly concentrates probability on the best observed actions. This can lead to fast improvement but risks overfitting to the finite sample of observed actions in the replay buffer.</p><p>When $\alpha$ is large, the exponential weights are all close to 1, and the regression becomes nearly unifor, which means that the policy doesn‚Äôt change much. This is safe but slow.</p><p>In practice, $\alpha$ needs to be tuned carefully. Too small and the policy collapses to imitating a few high-advantage actions (losing diversity and exploration). Too large and the policy barely improves. The right value of $\alpha$ depends on the scale of the advantage function, which itself depends on the reward scale of the specific problem.</p><h2 id="proximal-policy-optimization-ppo"><span class="mr-2">Proximal Policy Optimization (PPO)</span><a href="#proximal-policy-optimization-ppo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>PPO is one of the most widely used RL algorithms today, powering many real-world systems including early versions of ChatGPT‚Äôs RLHF training. It arises from a specific design choice in how we handle the off-policy optimization problem.</p><p>Recall that our general off-policy optimization problem (after approximating $d^\pi$ with $d^\mu$) is:</p>\[\max_{\pi} \mathbb{E}_{s \sim d^{\mu}(s)} \left[ \mathbb{E}_{a \sim \pi(\cdot|s)} [A^{\mu}(s, a)] \right] - \alpha D(\pi, \mu)\]<div class="table-wrapper"><table><tbody><tr><td>AWR used $D_{KL}(\pi<td>¬†<td>\mu)$ as the divergence, which gave a nice closed-form solution. PPO instead uses $D_{KL}(\mu<td>¬†<td>\pi)$, the reverse KL, leading to a very different (but equally principled) algorithm. The full PPO objective is:</table></div><aside> üí° $$ \max_{\theta} \mathbb{E}_{s \sim d^{\mu}(s)} \left[ \mathbb{E}_{a \sim \pi_{\theta}(\cdot|s)} [A^{\mu}(s, a)] \right] - \alpha D_{KL}(\mu(\cdot|s) \| \pi_{\theta}(\cdot|s)) $$</aside><p>The inner expectation is over actions sampled from $\pi_\theta$, not from $\mu$. This means we need to sample new actions from our current policy at each state. But what if we want to learn from the actions that $\mu$ already took? This is where importance sampling comes in.</p><h3 id="importance-sampling"><span class="mr-2">Importance Sampling</span><a href="#importance-sampling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Importance sampling is a technique for computing an expectation under one distribution using samples from a different distribution:</p>\[\mathbb{E}_{x \sim p(x)}[f(x)] = \mathbb{E}_{x \sim q(x)}\left[\frac{p(x)}{q(x)} f(x)\right]\]<p>The ratio $p(x)/q(x)$ is called the importance weight. It corrects for the fact that we‚Äôre sampling from the wrong distribution. Applied to our policy gradient, if we want to compute an expectation under $\pi_\theta$ but we only have actions sampled from $\mu$, we can write:</p><aside> üí° $$ \mathbb{E}_{a \sim \pi_{\theta}(\cdot|s)} [A^{\mu}(s,a)] = \mathbb{E}_{a \sim \mu(\cdot|s)} \left[ \frac{\pi_{\theta}(a|s)}{\mu(a|s)} A^{\mu}(s,a) \right] $$</aside><p>This is the ‚Äúimportance-weighted policy gradient.‚Äù Now we can use actions already stored in our replay buffer (sampled from $\mu$) and just reweight them by the probability ratio. Let‚Äôs define this ratio for convenience:</p>\[r(\theta) = \frac{\pi_{\theta}(a|s)}{\mu(a|s)}\]<p>The full PPO objective (before clipping) becomes:</p>\[\nabla_{\theta} \left[ \mathbb{E}_{s \sim d^{\mu}(s), a \sim \mu(\cdot|s)} \left[ \frac{\pi_{\theta}(a|s)}{\mu(a|s)} A^{\mu}(s,a) \right] - \alpha D_{KL}(\mu(\cdot|s) \| \pi_{\theta}(\cdot|s)) \right]\] \[D_{KL}(\mu(\cdot|s) \| \pi_{\theta}(\cdot|s)) = \mathbb{E}_{a \sim \mu(\cdot|s)} \left[ \log \mu(a|s) - \log \pi_{\theta}(a|s) \right]\] \[\nabla_{\theta} D_{KL}(\mu \| \pi_{\theta}) = -\mathbb{E}_{a \sim \mu(\cdot|s)} \left[ \nabla_{\theta} \log \pi_{\theta}(a|s) \right]\]<h3 id="do-we-actually-need-the-kl-term"><span class="mr-2">Do We Actually Need the KL Term?</span><a href="#do-we-actually-need-the-kl-term" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>At this point, we might think: the KL divergence term is there for theoretical reasons (to keep the approximation valid), but is it strictly necessary in practice? The answer is nuanced.</p><p>Strictly speaking, no the KL term is not a fundamental part of the optimization; it‚Äôs a regularizer to prevent $\pi_\theta$ from drifting too far from $\mu$. But if we simply remove it and maximize the importance-weighted objective without any constraint, our policy updates can become very large, completely invalidating the $d^\pi \approx d^\mu$ approximation and causing catastrophic policy degradation.</p><p><strong>How does $D_{KL}$ prevent this?</strong></p><p>The KL term penalizes $\theta$ whenever $\pi_\theta$ deviates from $\mu$. When you take the gradient of the full objective and do gradient ascent, the gradient of the first term (importance-weighted advantage) pushes $\theta$ toward higher-advantage actions, potentially making large changes. The gradient of the KL term simultaneously pushes $\theta$ back toward $\mu$, resisting those large changes.</p><p>The parameter $\alpha$ controls the strength of this resistance. A large $\alpha$ means the KL penalty dominates, keeping $\pi_\theta$ very close to $\mu$. A small $\alpha$ lets the advantage term dominate, allowing larger updates. At any given gradient step, these two forces balance each other, and the equilibrium point is a policy that improves on the advantage objective but doesn‚Äôt stray too far from $\mu$.</p><div class="table-wrapper"><table><tbody><tr><td><strong>Key Insight:</strong> notice that $D_{KL}(\mu<td>¬†<td>\pi_\theta)$ being small implies that $\pi_\theta$ and $\mu$ assign similar probabilities to all actions, which means the importance ratio $r(\theta) = \pi_\theta(a<td>s)/\mu(a<td>s)$ stays close to 1. So instead of explicitly computing and penalizing the KL divergence (which requires knowing $\mu$‚Äôs probabilities for all actions), we can equivalently constrain the importance ratio $r(\theta)$ to stay close to 1. This leads to the PPO clipping trick.</table></div><h3 id="the-ppo-clip-objective"><span class="mr-2">The PPO Clip Objective</span><a href="#the-ppo-clip-objective" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The practical PPO implementation replaces the KL penalty with a hard clip on the importance ratio:</p>\[\mathcal{L}^{\text{CLIP}}(\theta) = \mathbb{E}_{s \sim d^{\mu}(s), a \sim \mu(\cdot|s)} \left[ \text{clip}\left(\frac{\pi_{\theta}(a|s)}{\mu(a|s)}, 1-\varepsilon, 1+\varepsilon\right) \cdot A^{\mu} \right]\]<p>where $\epsilon$ is a hyperparameter (typically 0.1 or 0.2) that controls how much the policy is allowed to change. The clip function simply caps the importance ratio: if $r(\theta) &lt; 1-\epsilon$, we use $1-\epsilon$; if $r(\theta) &lt; 1+\epsilon$, we use $1+\epsilon$; otherwise we use $r(\theta)$ as-is.</p><p><strong>Intuition:</strong> We‚Äôre saying ‚Äúwe‚Äôll only trust our importance-weighted estimates when $\pi_\theta$ and $\mu$ are reasonably close (within $\epsilon$ of each other). Beyond that, we don‚Äôt let the gradient push us further.‚Äù This prevents the runaway updates that would occur without the KL penalty, but in a computationally simpler and more stable way.</p><p>In practice, the actual PPO objective uses a min to ensure we take a conservative update:</p>\[\mathcal{L}^{\text{CLIP}}(\theta) = \mathbb{E} \left[ \min\left( r(\theta) \cdot A^{\mu}, \; \text{clip}(r(\theta), 1-\varepsilon, 1+\varepsilon) \cdot A^{\mu} \right) \right]\]<p>The min ensures that we never benefit from going outside the trust region, even if the clipped value happens to be larger than the unclipped value in certain cases.</p><h3 id="problems-with-the-clip-objective"><span class="mr-2">Problems with the Clip Objective</span><a href="#problems-with-the-clip-objective" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The clipping approach works well in practice but has some subtle issues worth understanding. Let‚Äôs think through what happens in different cases by considering the sign of the advantage and the size of the ratio.</p><div class="table-wrapper"><table><tbody><tr><td><strong>Case 1:</strong> $r(\theta) &lt; 1-\epsilon$ and $A^\mu(s,a) &gt;0$. The action has low probability under $\pi_\theta$ relative to $\mu$, but it‚Äôs a good action (positive advantage). The clip fires and we use $r(\theta)\cdot A^\mu$ instead of $(1-\epsilon)¬∑A^\mu$. We still receive a gradient signal pushing us to increase $\pi_\theta(a<td>s)$, and this is correct behavior.</table></div><p><strong>Case 2:</strong> $r(\theta) &lt; 1-\epsilon$ and $A^\mu(s,a) &lt; 0$. The action has low probability under $\pi_\theta$, and it‚Äôs a bad action (negative advantage). We get no gradient signal here because of the min objective, since $\pi_\theta$ is already avoiding this and we use $(1-\epsilon)¬∑A^\mu$ instead of $r(\theta)\cdot A^\mu$. This is a good behavior.</p><p><strong>Case 3:</strong> $r(\theta) &gt; 1+\epsilon$ and $A^\mu(s,a) &lt; 0$. The action has high probability under $\pi_\theta$ but it‚Äôs a bad action. The clip fires and we use $(1+\epsilon)¬∑A^\mu$. We receive a gradient signal ‚Äúunlearning‚Äù this bad action, and hence this is correct behavior.</p><p><strong>Case 4:</strong> $r(\theta) &gt; 1+\epsilon$ and $A^\mu(s,a) &gt;0$. The action has high probability under $\pi_\theta$ and it‚Äôs a good action. The clip fires and we receive no gradient signal to further increase this action‚Äôs probability. This is a conservative choice ‚Äî we‚Äôre saying ‚Äúwe‚Äôve already increased this action‚Äôs probability enough; let‚Äôs not push further without fresh data.‚Äù This is what makes PPO safe, but it also hurts exploration: the policy won‚Äôt keep pushing toward good actions that it‚Äôs already committing to, which can slow learning.</p><p>The last case is particularly interesting because it represents a deliberate conservative choice: we‚Äôre not giving gradient signal to reinforce good actions that are already highly likely. This is justified theoretically (we don‚Äôt want to stray too far from the trust region), but can slow exploration in practice.</p><h3 id="the-asymmetric-clip-dapo"><span class="mr-2">The Asymmetric Clip: DAPO</span><a href="#the-asymmetric-clip-dapo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The clipping issues above motivate a variant called the asymmetric clip, used in the DAPO algorithm (particularly relevant for LLM training). The idea is to use different $\epsilon$ values for the upper and lower clipping thresholds:</p>\[\text{clip}\left(r(\theta), 1-\varepsilon_{\text{low}}, 1+\varepsilon_{\text{high}}\right) \quad \text{where} \quad \varepsilon_{\text{high}} &gt; \varepsilon_{\text{low}}\]<p>By using a larger $\varepsilon_{\text{high}}$ than $\varepsilon_{\text{low}}$, we allow the policy to more aggressively increase probability on good actions (larger trust region in the ‚Äúincrease‚Äù direction) while being more conservative about decreasing probability on bad actions (smaller trust region in the ‚Äúdecrease‚Äù direction). This asymmetry encourages more exploration by reducing the cases where we get no gradient signal for good actions.</p><h2 id="option-2-off-policy-actor-critic-with-a-learned-q-function"><span class="mr-2">Option 2: Off-Policy Actor-Critic with a Learned Q-Function</span><a href="#option-2-off-policy-actor-critic-with-a-learned-q-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Instead of using $A^\mu$ in our objective, what if we used $A^\pi$, the advantage of the current policy $\pi$? This requires learning $Q^\pi$ off-policy. The objective becomes:</p>\[\max_{\theta} \mathbb{E}_{s, a \sim \mu} [Q^{\pi}_{\phi}(s, a)]\]<p>The crucial insight here is that $Q^\pi$ can be learned from any data in the replay buffer because the Bellman equation for $Q^\pi$ doesn‚Äôt require on-policy data. We train $Q^\pi_\phi$ using the standard TD loss:</p>\[\mathcal{L}(\phi) = \mathbb{E}_{s, a, r, s' \sim \text{RB}} \left[ \left( Q_{\phi}(s,a) - y(s,a) \right)^2 \right]\]<p>where the target $y(s,a)$ uses the current policy $\pi_\theta$ to select the next action:</p>\[y(s,a) = r(s,a) + \gamma \mathbb{E}_{s' \sim p(\cdot|s,a), a' \sim \pi_{\theta}(\cdot|s')} [Q^{\text{target}}_{\bar{\phi}}(s', a')]\]<div class="table-wrapper"><table><tbody><tr><td>In practice, we compute this by sampling $a‚Äô \sim \pi_\theta(\cdot<td>s‚Äô)$ from the current policy and querying the target network $Q^{\text{target}}_{\bar{\phi}}(s‚Äô, a‚Äô)$. All the machinery we learned from value-based methods applies directly: target networks, soft/hard target updates, replay buffers, and so on. This is the foundation of DDPG and TD3, which we‚Äôll cover next.</table></div><p><strong>What are $\pi$ and $\mu$?</strong></p><ul><li>$\mu$ is the behavior policy ‚Äî the policy that actually interacts with the environment and collects data. It‚Äôs the policy whose transitions <code class="language-plaintext highlighter-rouge">(s, a, r, s')</code> get stored in the replay buffer.<li>$\pi_\theta$ is the target policy ‚Äî the policy we‚Äôre trying to optimize. It‚Äôs a neural network parameterized by $\theta$ that we‚Äôre improving through gradient ascent on the Q-function objective. Crucially, $\pi_\theta$ does NOT directly collect data. Instead, it participates in computing the Bellman target by selecting actions at the next state $s‚Äô$.</ul><h3 id="why-is-this-off-policy"><span class="mr-2">Why Is This Off-Policy?</span><a href="#why-is-this-off-policy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This looks like standard Q-learning because the critic training is essentially the same TD loss. But the crucial difference is that the data in the replay buffer was collected by $\mu$, not by $\pi_\theta$. In on-policy methods, every gradient update must use fresh data from the current policy ‚Äî you cannot reuse old data because the gradient estimates would be biased. Here, we‚Äôre explicitly reusing old data collected by $\mu$, which makes it off-policy.</p><p>The reason this works is that the Bellman equation for $Q^\pi$ holds for any state-action pair, regardless of which policy generated the data. When we train the critic using transitions from the replay buffer, we‚Äôre just supervising $Q_\phi(s,a)$ toward the TD target, and this supervision is valid regardless of how $(s,a)$ was generated. The states and actions just need to be real experiences from the environment, and don‚Äôt need to come from $\pi_\theta$ itself.</p><p>The policy update is also off-policy for the same reason. When we maximize $\mathbb{E}\left[Q_\phi(s, \pi_\theta(s))\right]$, the states $s$ come from $\mu$‚Äôs replay buffer, not from $\pi_\theta$‚Äôs own trajectories. We‚Äôre asking <em>‚Äúgiven states that $\mu$ visited, what action would $\pi_\theta$ take, and how good does the critic think that action is?‚Äù</em> This is an off-policy evaluation of $\pi_\theta$ using $\mu$‚Äôs state distribution.</p><h3 id="the-subtle-difference-from-pure-q-learning"><span class="mr-2">The Subtle Difference from Pure Q-Learning</span><a href="#the-subtle-difference-from-pure-q-learning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In pure Q-learning (like DQN), there‚Äôs no separate actor network ‚Äî the policy is just the implicit argmax of the Q-function. Here, we have an explicit policy network $\pi_\theta$ that we‚Äôre optimizing separately. This matters because in continuous action spaces, you can‚Äôt take an argmax over infinitely many actions. Instead, you maintain $\pi_\theta$ as a differentiable function and backpropagate through $Q_\phi$ into $\pi_\theta$ to push the policy toward higher-value actions. This is the actor-critic structure: the critic ($Q_\phi$) evaluates actions and the actor ($\pi_\theta$) is optimized to maximize those evaluations, all using off-policy data from $\mu$ stored in the replay buffer.</p><h3 id="why-do-we-maximize-qpi-and-not-api"><span class="mr-2">Why do we maximize $Q^\pi$ and not $A^\pi$?</span><a href="#why-do-we-maximize-qpi-and-not-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Recall the definition of advantage:</p>\[A^{\pi}(s, a) = Q^{\pi}(s, a) - V^{\pi}(s)\]<p>Now when we write the policy optimization objective, we‚Äôre taking an expectation over states $s$ and actions $a \sim \pi_\theta$:</p>\[\max_{\theta} \mathbb{E}_{s, a \sim \pi_{\theta}} \left[ A^{\pi}(s, a) \right] = \max_{\theta} \mathbb{E}_{s, a \sim \pi_{\theta}} \left[ Q^{\pi}(s, a) - V^{\pi}(s) \right]\]<p>Now look at the $V^\pi(s)$ term. It depends only on $s$, not on the action $a$. Since we‚Äôre optimizing over $\theta$, which only affects how actions are chosen, not which states we visit (we‚Äôre using states from $\mu$‚Äôs replay buffer), $V^\pi(s)$ is just a constant with respect to the optimization over $\theta$. Subtracting a constant from an objective doesn‚Äôt change where the maximum is. So:</p>\[\max_{\theta} \mathbb{E}_{s, a \sim \pi_{\theta}} \left[ Q^{\pi}(s, a) - V^{\pi}(s) \right] = \max_{\theta} \mathbb{E}_{s, a \sim \pi_{\theta}} \left[ Q^{\pi}(s, a) \right]\]<p>They have the same maximizer. The policy that maximizes expected Q-value is identical to the policy that maximizes expected advantage.</p><h2 id="ddpg-and-td3-off-policy-actor-critic-for-continuous-actions"><span class="mr-2"><strong>DDPG and TD3: Off-Policy Actor-Critic for Continuous Actions</strong></span><a href="#ddpg-and-td3-off-policy-actor-critic-for-continuous-actions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>These algorithms are specifically designed for continuous action spaces, where taking the argmax over actions (as in DQN) is intractable.</p><p>The key idea is to maintain both an explicit policy network $\pi_\theta$ (the actor) and a Q-function $Q_\phi$ (the critic), and alternate between updating them. The critic is trained using the TD loss above, and the actor is updated to maximize the Q-values:</p>\[\max_{\theta} \mathbb{E}_{s \sim \text{RB}} [Q_{\phi}(s, \pi_{\theta}(s))]\]<p>Since $\pi_\theta(s)$ is differentiable with respect to $\theta$, we can backpropagate through the Q-function all the way into the policy. This is called the deterministic policy gradient. The policy just shifts its output to wherever the Q-function says is best, guided by gradient ascent through the critic.</p><p>Both DDPG and TD3 inherit all the stability mechanisms we‚Äôve discussed: replay buffers to decorrelate data, target networks to stabilize the Q-function training, and soft target updates to prevent sudden shifts. TD3 additionally incorporates ideas like Double DQN (using two Q-networks to reduce overestimation bias) and delayed policy updates (updating the actor less frequently than the critic, giving the critic time to settle before the policy chases it).</p><h3 id="the-deterministic-policy-gradient-how-backprop-works-through-the-critic"><span class="mr-2">The Deterministic Policy Gradient: How Backprop Works Through the Critic</span><a href="#the-deterministic-policy-gradient-how-backprop-works-through-the-critic" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Now, the key question is: how exactly do we compute $\nabla_\theta \mathbb{E}[Q^\pi_\phi(s, a)]$ when $a$ comes from $\pi_\theta$? If the policy is deterministic, meaning it outputs a single action $a_\theta(s)$ rather than a distribution, then we can apply the chain rule directly:</p>\[\nabla_{\theta} Q^{\pi}_{\phi}(s, a_{\theta}(s)) = \nabla_{a} Q^{\pi}_{\phi}(s, a) \big|_{a = a_{\theta}(s)} \cdot \nabla_{\theta} a_{\theta}(s)\]<p>This is the deterministic policy gradient.</p><p><strong>Interpretation:</strong> First, ask the critic ‚Äúwhich direction should I push the action to increase $Q$?‚Äù (that‚Äôs $\nabla_a Q$), and then ask the policy ‚Äúhow does changing $\theta$ change the action?‚Äù (that‚Äôs $\nabla_\theta a_\theta(s)$). Multiply these together via the chain rule and you have a gradient that flows all the way from the Q-function back into the policy parameters. This is exactly what DDPG uses ‚Äî the gradient signal travels from the Q-network, through the action, into the policy network.</p><p><strong>What is the policy is stochastic?</strong></p><div class="table-wrapper"><table><tbody><tr><td>If the policy is stochastic instead, outputting a Gaussian distribution $\pi_\theta(\cdot<td>s) = \mathcal{N}(\mu_\theta(s), \sum_\theta(s))$, then we can‚Äôt directly differentiate through sampling. Instead, we use the reparameterization trick: sampling $a \sim \pi_\theta(\cdot<td>s)$ is equivalent to sampling $\epsilon \sim \mathcal{N}(0, I)$ and computing $a = \pi_\theta(s) + \epsilon \cdot \sigma_\theta(s)$. Now $a$ is a deterministic function of $\epsilon$ and $\theta$, so we can backpropagate through it. This is what SAC uses.</table></div><h3 id="ddpg-and-td3-the-full-algorithm"><span class="mr-2">DDPG and TD3: The Full Algorithm</span><a href="#ddpg-and-td3-the-full-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>With the deterministic policy gradient in hand, we can now describe DDPG and its improved variant TD3. The core structure has two interacting components: a deterministic policy network $\pi_\theta(s)$ (the actor) and a Q-function network $Q_\phi(s,a)$ (the critic).</p><p><strong>Training the Critic:</strong> We sample transitions <code class="language-plaintext highlighter-rouge">(s, a, r, s')</code> from the replay buffer and minimize the TD loss:</p>\[\mathcal{L}(\phi) = \mathbb{E}_{s,a,r,s' \sim \text{RB}} \left[ \left( Q_{\phi}(s,a) - y(s,a) \right)^2 \right]\]<p>where the target is computed using the target networks and the current policy:</p>\[y(s,a) = r(s,a) + \gamma \min\left( Q^{\text{target}}_{\phi_1}(s', a'), Q^{\text{target}}_{\phi_2}(s', a') \right), \quad a' \leftarrow \pi_{\theta}(s') + \varepsilon\]<p>Notice two things here. First, we use two Q-networks $Q_{\phi1}$ and $Q_{\phi2}$ and take the minimum of their predictions when computing the target. This is the Double Q-learning trick borrowed from DQN ‚Äî it directly addresses overestimation bias, because if either network overestimates, the $\min$ operator selects the more conservative (lower) estimate. Second, we add a small noise $\epsilon$ to the next action $a‚Äô$ when computing the target. This is called target policy smoothing and prevents the policy from exploiting sharp Q-function peaks that might be artifacts of function approximation error.</p><p><strong>Data Collection:</strong> Data is collected by running the deterministic policy with added exploration noise:</p>\[a \sim \pi_{\theta}(s) + \varepsilon, \quad \varepsilon \sim \mathcal{N}(0, \sigma^2)\]<p>Since a deterministic policy always outputs the same action for a given state, it would never explore without this noise. The noise provides the necessary stochasticity during data collection.</p><p><strong>Training the Actor:</strong> The policy is updated to maximize the Q-function using the deterministic policy gradient:</p>\[\theta' \leftarrow \theta + \eta \nabla_{\theta} \mathbb{E}_{s \sim \text{RB}} \left[ Q_{\phi_1}(s, \pi_{\theta}(s)) \right]\]<p>One important detail in TD3: the actor is updated less frequently than the critic, typically once every $d$ critic updates ($d=2$ is common). The motivation is to let the critic stabilize before the policy chases after it. If the policy updates as fast as the critic, it might end up chasing noisy or inaccurate Q-value estimates, destabilizing training.</p><h3 id="is-there-a-separate-policy-mu"><span class="mr-2">Is there a separate policy $\mu$?</span><a href="#is-there-a-separate-policy-mu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Yes and no. There is no separate policy $\mu$ that‚Äôs distinct from $\pi_\theta$. Instead, $\mu$ is just an older or noisier version of $\pi_\theta$ itself.</p><p>In DDPG/TD3, the ‚Äúbehavior policy‚Äù $\mu$ that collects data is simply:</p>\[\mu(a|s) = \pi_{\theta_{\text{old}}}(s) + \varepsilon, \quad \varepsilon \sim \mathcal{N}(0, \sigma^2)\]<p>where $\pi_{\theta_{\text{old}}}$ is the policy from some previous iteration (or even the current iteration), and $\epsilon$ is exploration noise. So $\mu$ is not a separately maintained network ‚Äî it‚Äôs the actor network $\pi_\theta$, possibly from a few steps ago, with Gaussian noise added for exploration.</p><p><strong>The Replay Buffer Perspective</strong></p><p>The replay buffer in DDPG/TD3 contains transitions <code class="language-plaintext highlighter-rouge">(s, a, r, s')</code> that were collected by running $\pi_\theta + \epsilon$ at various points during training. So the $\mu$ we keep referring to is really a mixture of past versions of $\pi_\theta$, all with exploration noise added.</p><p>When we say ‚Äústates come from $d^\mu$,‚Äù we mean: the states in the replay buffer were visited by various historical versions of $\pi_\theta$ (with noise), and we‚Äôre reusing those states to train the current $\pi_\theta$.</p><p><strong>Why This Works (Off-Policy Nature)</strong></p><p>The key insight is that DDPG/TD3 don‚Äôt care which policy generated the data in the replay buffer, as long as:</p><ol><li>The Q-function can be learned from that data (which it can, because Bellman equations hold for any state-action pairs)<li>The states cover regions where the current policy $\pi_\theta$ actually operates (which they do if $\pi_\theta$ hasn‚Äôt changed too drastically)</ol><p>So unlike PPO where $\mu$ is explicitly the ‚Äúold policy‚Äù from the previous iteration and we carefully track the distribution mismatch with importance ratios, in DDPG/TD3 we just say ‚Äú$\mu$ is whatever policy (or mixture of policies) generated the data in the replay buffer‚Äù and we don‚Äôt worry about correcting for distribution shift ‚Äî we just trust that the off-policy learning will work as long as the data is reasonably diverse and recent.</p><p><strong>Comparison to AWR/PPO</strong></p><p>To clarify the distinction:</p><ul><li>PPO/AWR: $\mu$ is explicitly defined as $\pi_{\theta_{\text{old}}}$ from the previous iteration. We track it carefully and either use importance sampling (PPO) or solve a constrained optimization (AWR) to account for the distribution shift.<li>DDPG/TD3: $\mu$ is implicitly ‚Äúwhatever generated the replay buffer data.‚Äù We don‚Äôt explicitly track it or correct for it ‚Äî we just assume the off-policy Q-learning will handle the distribution shift automatically.</ul><p>This is one reason DDPG/TD3 can be less stable than SAC. There‚Äôs no explicit mechanism to keep $\pi_\theta$ close to the data distribution, so if the policy changes too quickly, it can end up in regions of the state-action space where the Q-function is poorly trained, leading to bad updates. SAC‚Äôs entropy regularization helps with this by keeping the policy ‚Äúspread out‚Äù and thus naturally staying closer to the data distribution.</p><h2 id="soft-actor-critic-sac"><span class="mr-2">Soft Actor-Critic (SAC)</span><a href="#soft-actor-critic-sac" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>SAC represents a conceptually deeper departure from DDPG/TD3 than just an engineering improvement. It is built on a fundamentally different objective called Maximum Entropy RL.</p><h3 id="what-is-maximum-entropy-rl"><span class="mr-2">What is Maximum Entropy RL?</span><a href="#what-is-maximum-entropy-rl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Standard RL seeks a policy that maximizes expected cumulative reward:</p>\[\pi^*_{\text{RL}} = \arg\max_{\pi} \mathbb{E}_{\tau \sim \pi} \left[ \sum_t \gamma^t r(s_t, a_t) \right]\]<p>Maximum Entropy RL adds a bonus for the policy being uncertain (i.e., having high entropy):</p>\[\pi^*_{\text{maxent}} = \arg\max_{\pi} \mathbb{E}_{\tau \sim \pi} \left[ \sum_{t=0}^{\infty} \gamma^t \left( r(s_t, a_t) + \alpha \mathcal{H}(\pi(\cdot|s_t)) \right) \right]\]<div class="table-wrapper"><table><tbody><tr><td>where $\mathcal{H}(\pi(\cdot<td>s_t))$ is the entropy of the policy‚Äôs action distribution at state $s_t$:</table></div>\[\mathcal{H}(\pi(\cdot|s_t)) = \mathbb{E}_{a \sim \pi(\cdot|s_t)} \left[ -\log \pi(\cdot|s_t) \right]\]<p>So at every time step, the policy is rewarded not just for taking high-reward actions, but also for being as random as possible ‚Äî for spreading probability across many actions rather than collapsing onto a single one. The temperature $\alpha$ controls this trade-off: large $\alpha$ means exploration is heavily rewarded, small $\alpha$ recovers standard RL.</p><p><strong>Intuition:</strong> Think of standard RL as a student who memorizes only the answer to a specific exam problem. MaxEnt RL is like a student who tries to understand all plausible solutions to a problem ‚Äî even if one solution is clearly best, it maintains some understanding of other approaches. This breadth of knowledge turns out to be crucial for generalization and robustness.</p><h3 id="simplifying-the-maxent-objective"><span class="mr-2">Simplifying the MaxEnt Objective</span><a href="#simplifying-the-maxent-objective" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><tbody><tr><td>The entropy term can be pulled inside the sum and absorbed into a modified reward function. Since $\mathcal{H}(\pi(\cdot<td>s_t)) = \mathbb{E}_{a \sim \pi(\cdot<td>s_t)} \left[ -\log \pi(\cdot<td>s_t) \right]$, we can write the whole objective as:</table></div>\[\pi^*_{\text{maxent}} = \arg\max_{\pi} \mathbb{E}_{\tau \sim \pi} \left[ \sum_{t=0}^{\infty} \gamma^t \left( r(s_t, a_t) - \alpha \log \pi(a_t|s_t) \right) \right]\]<p>This gives us a modified reward:</p>\[\tilde{r}_{\alpha}(s, a) = r(s, a) - \alpha \log \pi(a|s)\]<div class="table-wrapper"><table><tbody><tr><td>This is an elegant simplification: we‚Äôve turned MaxEnt RL into standard RL, just with a reward function that includes a penalty for being too deterministic. The $-\alpha \log \pi(a<td>s)$ term acts as an intrinsic reward for exploration ‚Äî actions that the policy assigns low probability to (meaning they‚Äôre surprising/exploratory) have a large $-\log \pi$ value and thus contribute more intrinsic reward.</table></div><p>Backup the entropy: the entropy bonus at each time step gets backed up through the Bellman equation, just like rewards do, so the Q-function automatically accounts for future entropy bonuses throughout the trajectory.</p><h3 id="the-sac-q-function"><span class="mr-2">The SAC Q-Function</span><a href="#the-sac-q-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Substituting the modified reward into the Bellman equation gives SAC‚Äôs Q-function update:</p>\[Q(s, a) \leftarrow r(s,a) + \gamma \mathbb{E}_{a' \sim \pi} \left[ Q(s', a') - \alpha \log \pi(a'|s') \right]\]<div class="table-wrapper"><table><tbody><tr><td>Compare this to TD3‚Äôs Bellman update, which just has $r(s,a) + \gamma \mathbb{E}[Q(s‚Äô,a‚Äô)]$. SAC‚Äôs update additionally subtracts $\alpha \log \pi(a‚Äô<td>s‚Äô)$ from the target, which means Q-values are lower for actions that the policy takes with high probability. This elegantly discourages the policy from collapsing onto a single action even when it‚Äôs the best-reward action.</table></div><h3 id="sacs-policy-update"><span class="mr-2">SAC‚Äôs Policy Update</span><a href="#sacs-policy-update" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>For the policy update, SAC also benefits from the MaxEnt objective. The gradient update for the policy becomes:</p>\[\theta' \leftarrow \theta + \eta \nabla_{\theta} \mathbb{E}_{a \sim \pi_{\theta}(\cdot|s)} \left[ Q_{\phi}(s, a) - \alpha \log \pi_{\theta}(a|s) \right]\]<p>The policy is now simultaneously trying to maximize Q-values (exploit good actions) and maximize entropy (stay diverse and exploratory). These are competing objectives kept in balance by $\alpha$. When $\alpha$ is large, the policy spreads out; when $\alpha$ is small, it concentrates on high-Q actions. This balance is what gives SAC its remarkable stability. Unlike DDPG which can suddenly collapse its policy onto a single action, SAC always maintains a floor of exploration.</p><h3 id="practical-design-choices-in-sac"><span class="mr-2">Practical Design Choices in SAC</span><a href="#practical-design-choices-in-sac" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>SAC makes three key practical design decisions that distinguish it from DDPG/TD3.</p><ol><li><p>Like TD3, SAC uses two critic networks and takes the minimum of their Q-value estimates. This is critical in SAC because the policy is stochastic and is being trained to maximize Q-values. If either Q-network overestimates, the policy will exploit that overestimation and degrade. The $\min$ operator provides a conservative lower bound:</p>\[Q_{\text{target}} = r + \gamma \mathbb{E}_{a'} \left[ \min(Q_{\phi_1}(s', a'), Q_{\phi_2}(s', a')) - \alpha \log \pi(a'|s') \right]\]<li>SAC requires no explicit exploration noise during data collection, unlike DDPG/TD3 which must add Gaussian noise to a deterministic policy. Because $\pi_\theta$ is inherently stochastic (a Gaussian whose variance is also learned), every action sampled from it naturally has uncertainty. The entropy term in the objective actively encourages this uncertainty to remain non-negligible throughout training, so exploration emerges automatically from the policy itself.<li><div class="table-wrapper"><table><tbody><tr><td>The temperature $\alpha$ is dynamically tuned during training. Rather than treating $\alpha$ as a fixed hyperparameter, SAC frames it as a constrained optimization: we want the policy to maintain at least a target level of entropy $\mathcal{H}_{\text{target}}$ (which is typically set to $-<td>\mathcal{A}<td>$, the negative dimensionality of the action space). The value of $\alpha$ is then automatically adjusted to ensure this constraint is met. If the policy‚Äôs entropy falls below the target, $\alpha$ increases to encourage more exploration; if it‚Äôs above the target, $\alpha$ decreases to let the policy specialize.</table></div></ol><h3 id="why-does-adding-entropy-help"><span class="mr-2">Why Does Adding Entropy Help?</span><a href="#why-does-adding-entropy-help" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The entropy bonus has two deeply important practical benefits. First, a stochastic policy is simply easier to optimize than a deterministic one. The optimization landscape is smoother because the policy‚Äôs output is a distribution, not a point ‚Äî gradients flow more reliably and the policy doesn‚Äôt get stuck in sharp local optima as easily. Second, and more fundamentally, the entropy bonus creates ‚Äúmore ways to succeed.‚Äù Rather than converging to a single behavior that achieves high reward, MaxEnt RL finds a distribution over behaviors that are all approximately equally good. If the environment has multiple valid strategies, SAC discovers all of them. This makes SAC much more robust: if one strategy stops working (due to environment changes or unseen situations), the policy still knows about other strategies and can switch.</p><p>Think of it like this: a deterministic policy is like a chess player who has memorized one perfect opening. A MaxEnt policy is like a chess player who has mastered many different openings. Against a novel opponent, the second player is far more adaptable.</p><h2 id="summary-ddpg-vs-td3-vs-sac"><span class="mr-2">Summary: DDPG vs TD3 vs SAC</span><a href="#summary-ddpg-vs-td3-vs-sac" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>All three algorithms share the same fundamental structure, an off-policy actor-critic with a replay buffer and target networks, but differ in key design choices.</p><ul><li>DDPG uses a deterministic policy with a single Q-network, making it simple but prone to overestimation and instability.<li>TD3 fixes DDPG‚Äôs instability with two Q-networks (clipped double Q), delayed policy updates, and target policy smoothing.<li>SAC goes further by switching to a stochastic policy with a MaxEnt objective, which provides natural exploration, better optimization landscapes, and automatic entropy tuning, but at the cost of slightly more complexity.</ul><p>In practice, SAC tends to be the most reliable of the three, which is why it remains a dominant algorithm for continuous control tasks today.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blog/'>Blog</a>, <a href='/categories/robotics/'>Robotics</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/learning/" class="post-tag no-text-decoration" >learning</a> <a href="/tags/rl/" class="post-tag no-text-decoration" >rl</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://www.facebook.com/sharer/sharer.php?title=Deep+Reinforcement+Learning+-+Bhaswanth+Ayapilla&u=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fdeep-rl%2F" data-toggle="tooltip" data-placement="top" title="Instagram" target="_blank" rel="noopener" aria-label="Instagram"> <i class="fa-fw fab fa-instagram"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Deep+Reinforcement+Learning+-+Bhaswanth+Ayapilla&u=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fdeep-rl%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fdeep-rl%2F&text=Deep+Reinforcement+Learning+-+Bhaswanth+Ayapilla" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fbhaswanth-a.github.io%2F%2Fposts%2Fdeep-rl%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/intro-to-rl/">Introduction to Reinforcement Learning</a><li><a href="/posts/reinforcement-learning/">Reinforcement Learning</a><li><a href="/posts/deep-rl/">Deep Reinforcement Learning</a><li><a href="/posts/lunar-roadster-cmu/">Lunar ROADSTER</a><li><a href="/posts/cmu-blog/">Coursework at CMU</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/learning/">learning</a> <a class="post-tag" href="/tags/nnets/">nnets</a> <a class="post-tag" href="/tags/rl/">rl</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/arduino/">arduino</a> <a class="post-tag" href="/tags/computer-vision/">computer vision</a> <a class="post-tag" href="/tags/control/">control</a> <a class="post-tag" href="/tags/electronics/">electronics</a> <a class="post-tag" href="/tags/manipulators/">manipulators</a> <a class="post-tag" href="/tags/ml/">ml</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/intro-to-rl/"><div class="card-body"> <em class="small" data-ts="1768838400" data-df="ll" > Jan 19, 2026 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Introduction to Reinforcement Learning</h3><div class="text-muted small"><p> In Progress This blog is a collection of my notes based on the book ‚ÄúReinforcement Learning: An Introduction by Richard S. Sutton and Andrew G. Barto‚Äù. Finite Markov Decision Processes Context ...</p></div></div></a></div><div class="card"> <a href="/posts/advanced-deep-rl/"><div class="card-body"> <em class="small" data-ts="1771084800" data-df="ll" > Feb 14, 2026 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Advanced Deep Reinforcement Learning</h3><div class="text-muted small"><p> In Progress</p></div></div></a></div><div class="card"> <a href="/posts/reinforcement-learning/"><div class="card-body"> <em class="small" data-ts="1768838400" data-df="ll" > Jan 19, 2026 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Reinforcement Learning</h3><div class="text-muted small"><p> Deep Learning This series of blogs are my notes from the class 10-703 Deep Reinforcement Learning and Control, taught by Katerina Fragkiadaki and Aviral Kumar at CMU, as well as learnings from the...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/robot-learning/" class="btn btn-outline-primary" prompt="Older"><p>Robot Learning</p></a> <a href="/posts/advanced-deep-rl/" class="btn btn-outline-primary" prompt="Newer"><p>Advanced Deep Reinforcement Learning</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Bhaswanth-A/bhaswanth-a.github.io", "data-repo-id": "R_kgDOHu5z_w", "data-category": "General", "data-category-id": "DIC_kwDOHu5z_84C0yVx", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> ¬© 2026 <a href="https://github.com/Bhaswanth-A">Bhaswanth Ayapilla</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/learning/">learning</a> <a class="post-tag" href="/tags/nnets/">nnets</a> <a class="post-tag" href="/tags/rl/">rl</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/arduino/">arduino</a> <a class="post-tag" href="/tags/computer-vision/">computer vision</a> <a class="post-tag" href="/tags/control/">control</a> <a class="post-tag" href="/tags/electronics/">electronics</a> <a class="post-tag" href="/tags/manipulators/">manipulators</a> <a class="post-tag" href="/tags/ml/">ml</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG ‚Ä∫ <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-CJ97GH1VYR"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-CJ97GH1VYR'); }); </script>
